[{"path":[]},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"CC0 1.0 Universal","title":"CC0 1.0 Universal","text":"CREATIVE COMMONS CORPORATION LAW FIRM PROVIDE LEGAL SERVICES. DISTRIBUTION DOCUMENT CREATE ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES INFORMATION “-” BASIS. CREATIVE COMMONS MAKES WARRANTIES REGARDING USE DOCUMENT INFORMATION WORKS PROVIDED HEREUNDER, DISCLAIMS LIABILITY DAMAGES RESULTING USE DOCUMENT INFORMATION WORKS PROVIDED HEREUNDER.","code":""},{"path":"/LICENSE.html","id":"statement-of-purpose","dir":"","previous_headings":"","what":"Statement of Purpose","title":"CC0 1.0 Universal","text":"laws jurisdictions throughout world automatically confer exclusive Copyright Related Rights (defined ) upon creator subsequent owner(s) (, “owner”) original work authorship /database (, “Work”). Certain owners wish permanently relinquish rights Work purpose contributing commons creative, cultural scientific works (“Commons”) public can reliably without fear later claims infringement build upon, modify, incorporate works, reuse redistribute freely possible form whatsoever purposes, including without limitation commercial purposes. owners may contribute Commons promote ideal free culture production creative, cultural scientific works, gain reputation greater distribution Work part use efforts others. /purposes motivations, without expectation additional consideration compensation, person associating CC0 Work (“Affirmer”), extent owner Copyright Related Rights Work, voluntarily elects apply CC0 Work publicly distribute Work terms, knowledge Copyright Related Rights Work meaning intended legal effect CC0 rights. Copyright Related Rights. Work made available CC0 may protected copyright related neighboring rights (“Copyright Related Rights”). Copyright Related Rights include, limited , following: right reproduce, adapt, distribute, perform, display, communicate, translate Work; moral rights retained original author(s) /performer(s); publicity privacy rights pertaining person’s image likeness depicted Work; rights protecting unfair competition regards Work, subject limitations paragraph 4(), ; rights protecting extraction, dissemination, use reuse data Work; database rights (arising Directive 96/9/EC European Parliament Council 11 March 1996 legal protection databases, national implementation thereof, including amended successor version directive); similar, equivalent corresponding rights throughout world based applicable law treaty, national implementations thereof. Waiver. greatest extent permitted , contravention , applicable law, Affirmer hereby overtly, fully, permanently, irrevocably unconditionally waives, abandons, surrenders Affirmer’s Copyright Related Rights associated claims causes action, whether now known unknown (including existing well future claims causes action), Work () territories worldwide, (ii) maximum duration provided applicable law treaty (including future time extensions), (iii) current future medium number copies, (iv) purpose whatsoever, including without limitation commercial, advertising promotional purposes (“Waiver”). Affirmer makes Waiver benefit member public large detriment Affirmer’s heirs successors, fully intending Waiver shall subject revocation, rescission, cancellation, termination, legal equitable action disrupt quiet enjoyment Work public contemplated Affirmer’s express Statement Purpose. Public License Fallback. part Waiver reason judged legally invalid ineffective applicable law, Waiver shall preserved maximum extent permitted taking account Affirmer’s express Statement Purpose. addition, extent Waiver judged Affirmer hereby grants affected person royalty-free, non transferable, non sublicensable, non exclusive, irrevocable unconditional license exercise Affirmer’s Copyright Related Rights Work () territories worldwide, (ii) maximum duration provided applicable law treaty (including future time extensions), (iii) current future medium number copies, (iv) purpose whatsoever, including without limitation commercial, advertising promotional purposes (“License”). License shall deemed effective date CC0 applied Affirmer Work. part License reason judged legally invalid ineffective applicable law, partial invalidity ineffectiveness shall invalidate remainder License, case Affirmer hereby affirms () exercise remaining Copyright Related Rights Work (ii) assert associated claims causes action respect Work, either case contrary Affirmer’s express Statement Purpose. Limitations Disclaimers. trademark patent rights held Affirmer waived, abandoned, surrendered, licensed otherwise affected document. Affirmer offers Work -makes representations warranties kind concerning Work, express, implied, statutory otherwise, including without limitation warranties title, merchantability, fitness particular purpose, non infringement, absence latent defects, accuracy, present absence errors, whether discoverable, greatest extent permissible applicable law. Affirmer disclaims responsibility clearing rights persons may apply Work use thereof, including without limitation person’s Copyright Related Rights Work. , Affirmer disclaims responsibility obtaining necessary consents, permissions rights required use Work. Affirmer understands acknowledges Creative Commons party document duty obligation respect CC0 use Work.","code":""},{"path":[]},{"path":"/TODO.html","id":"coding-stuff","dir":"","previous_headings":"TODO","what":"Coding stuff","title":"NA","text":"prep_gsp_for_hap_dropping() write quick check ensure column types GSP tibble correct (NAs character “NAs”, etc.) check_chrom_lengths() function (see tutorial vignette line 162) Function check validity GSPs. Figure recombination rates adjacent markers work within existing framework. (, take lot longer. just leave large bins) Check xover() deal happens new breakpoint occurs exactly existing one, explicit documentation whether breaks occur “left” “right” breakpoint.","code":""},{"path":"/TODO.html","id":"functions-to-document","dir":"","previous_headings":"TODO > Coding stuff","what":"Functions To Document:","title":"NA","text":"big-wrapper() check_chrom_lengths() check_gsp_for_validity_and_saturation() check_pedigree_for_inbreeding() computeQs_from_segments() create_GSP() (just needs F1B F1B2 params documented!) data() (Needs mild description editing data objects) drop-segs--gsp() full_analysis() HIGH PRIORITY. JUST VISUALIZTION gsp2dot() import() make_subscript_matrix() mat_scramble() perm_gs_by_pops() plot_simulated_chromosome_segments() prep_gsp_for_hap_dropping() rearrange_genos() recomb_point() seg2tib() seg_haps_through_gsp() segregate() sim_level_founder_haplos() tidy_up_sampled_haplos() xover() ### paper concise mathematical description components GSP, constraints .","code":""},{"path":"/TODO.html","id":"for-thinking","dir":"","previous_headings":"TODO","what":"For thinking","title":"NA","text":"Can come framework specifying GSP requests user desired end results (.e. number individuals different hybrid categories.able figure given constraints.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"/articles/gscramble-tutorial.html","id":"input-data","dir":"Articles","previous_headings":"","what":"Input Data","title":"A first tutorial for `gscramble`","text":"gscramble operates diploid species. main functions gscramble require genetic data provided R objects (matrices/tibbles/etc.) particular formatting. describe formats objects . Later describe functions reading data PLINK format (perhaps others, future) necessary objects gscramble. main required objects : matrix genotype data. (Geno) tibble meta data individuals genotype data (I_meta) tibble meta data markers genotype data (M_meta) top , want simulate hybrid individuals according pedigree, might also need provide tibble describes rates genetic recombination along chromosomes. (RecRates) tibble describes pedigree gene dropping chromosome chunks, call “genome simulation pedigree” (GSP) tibble matches population specifiers pedigree genetic data different replicates (RepPop) Examples objects (heavily downsampled make small enough host CRAN) data set feral pigs (CITATION) included data objects package. following sections discuss data inputs detail.","code":""},{"path":"/articles/gscramble-tutorial.html","id":"matrix-of-genotype-data--geno","dir":"Articles","previous_headings":"Input Data","what":"Matrix of genotype data. Geno","title":"A first tutorial for `gscramble`","text":"genotype data must provided matrix. \\(N\\) individuals \\(L\\) loci diploid species, matrix \\(N\\) rows \\(2L\\) columns. locus gets two adjacent columns individual gets one row. , example, first row first column allelic type first two gene copies first individual first locus. first row second column second two gene copies first individual first locus. first row third column first gene copy second locus first individual, . example data first 6 loci first 4 individuals package data Geno: data must stored character Matrix. Don’t pass matrix integers. alleles can characters whatsoever. allows data microsatellites, (\"112\", \"116\", etc), microhaplotypes (\"ACCGA\", \"ACCTC\", etc.), SNPs (\"\", \"C\", \"G\", \"T\"), etc. matrix integers, named, example IntMat can coerce elements matrix characters, without losing matrix shape data, : Missing genotype data must denoted standard R missing data specifier, NA. Don’t go around calling missing data \"-1\" expect work properly! Change \"-1\"’s NAs, regarded allelic type, rather missing data.","code":"Geno[1:4, 1:12] #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #> [1,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  \"A\"  \"A\"  \"G\"  \"G\"   \"T\"   \"T\"   #> [2,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  \"A\"  \"A\"  \"G\"  \"G\"   \"T\"   \"T\"   #> [3,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  \"A\"  \"A\"  \"G\"  \"G\"   \"T\"   \"T\"   #> [4,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  \"A\"  \"A\"  \"G\"  \"G\"   \"T\"   \"T\" storage.mode(IntMat) <- \"character\""},{"path":"/articles/gscramble-tutorial.html","id":"individual-meta-data--i_meta","dir":"Articles","previous_headings":"Input Data","what":"Individual meta data. I_meta","title":"A first tutorial for `gscramble`","text":"tibble gives information individuals whose genotypes Geno. can many different columns want , must least two columns: group: column gives character name group/cluster/population individual considered part . indiv: column gives character ID individual. number rows tibble exactly equal number rows Geno order individuals I_meta must correspond exactly order individuals Geno. first rows example data’s I_meta look like:","code":"head(I_meta) #> # A tibble: 6 × 2 #>   group indiv     #>   <chr> <chr>     #> 1 Pop2  ID0033692 #> 2 Pop2  ID0014942 #> 3 Pop2  ID0014961 #> 4 Pop2  ID0016971 #> 5 Pop2  ID0016972 #> 6 Pop2  ID0017013"},{"path":"/articles/gscramble-tutorial.html","id":"marker-meta-data--m_meta","dir":"Articles","previous_headings":"Input Data","what":"Marker meta data. M_meta","title":"A first tutorial for `gscramble`","text":"input tibble information markers Geno matrix. can variety columns , required three: chrom: character name chromosome upon marker occurs. example, \"1\" \"X\" \"Omy28\". Importantly, simulating physical linkage recombination, names chromosomes file must correspond exactly names chromosomes RecRates (see next section). pos: numeric (integer double) column giving position marker (typically base pairs, arbitrary units correspond position units RecRates), along chromosome. position values must greater 0. variant_id: character vector unique ID names markers. globally unique, .e., don’t two markers different chromosomes named thing. must exactly half many rows M_meta columns Geno, order markers M_meta must correspond exactly order markers columns Geno. first rows example data M_meta:","code":"head(M_meta) #> # A tibble: 6 × 3 #>   chrom      pos variant_id          #>   <chr>    <dbl> <chr>               #> 1 12     4469057 WU_10.2_12_4469057  #> 2 12     5238225 ALGA0064411         #> 3 12     7394362 WU_10.2_12_7394362  #> 4 12     7651064 ASGA0090707         #> 5 12     8971475 WU_10.2_12_8971475  #> 6 12    11034660 WU_10.2_12_11034660"},{"path":"/articles/gscramble-tutorial.html","id":"recombination-rates--recrates","dir":"Articles","previous_headings":"Input Data","what":"Recombination rates. RecRates","title":"A first tutorial for `gscramble`","text":"tibble gives information rate recombinations genome. necessary simulating linked markers. required gscramble know crossover rate recombination rate every adjacent pair markers (though information, can provide RecRates, (see ). Rather, rate recombination can specified terms per-meiosis probability recombination number (preferably relatively short—example, one megabase less) bins. RecRates tibble required four columns: chrom: chromosome bin occurs. Note chromosome nomenclature must match exactly used M_meta. chrom_len: length chromosome. Yes, value chromosome typically duplicated row occupied chrom. start_pos: starting position bin. typically position along chromosome base pairs, though position can units, long corresponds position used M_meta. end_pos: ending position bin. rec_prob: per-meiosis probability recombination occurring bin. important notes: start point bin 1 greater end point preceding bin. positions markers (M_meta) included amongst bin intervals defined start_pos end_pos. crucially regard, smallest start_pos less smallest pos M_meta greatest end_pos greater equal largest pos M_meta. Otherwise, recombination might never possible pairs markers data set. chromosome length chrom_len must exceed position every marker chromosome M_meta. case possible markers dropped data set, possibly unexpected bad results. can check errors regard using function check_chrom_lengths().","code":""},{"path":"/articles/gscramble-tutorial.html","id":"genome-simulation-pedigree--gsp","dir":"Articles","previous_headings":"Input Data","what":"Genome Simulation Pedigree. GSP","title":"A first tutorial for `gscramble`","text":"GSP specification pedigree sections chromosome get segregated guide sampling without replacement genetic material hybrid individuals purpose assessing power identifying individuals. GSP must tibble individual numeric identifier (1 number individuals pedigree.) founders’ parents listed NA non-founders parents listed. Founders’ haplotypes must unique IDs must originate specified population (typically given capital letters.) Individuals can sampled individuals pedigree, user indicate many gametes must segregated individuals (two parents) order consume genetic material present founders. probably sounds little abstract, , indeed, . try explain GSP concept fully, first draw picture one, show tibble representation GSP discuss structure GSP light two pieces information. package data object GSP shows example genome simulation pedigree. fairly complex pedigree 13 members. picture looks like: can produce type plot using gsp2dot() function ‘gscramble’ package, requires installation GraphViz dot software. tibble specification GSP printed :","code":"csv <- system.file(\"extdata/13-member-ped.csv\", package = \"gscramble\") gsp_tib <- readr::read_csv(csv) paths <- gsp2dot(g = gsp_tib, path = \"images/13-member-ped\") # now, get rid of the dot and png files file.remove(paths[1:2]) csv <- system.file(\"extdata/13-member-ped.csv\", package = \"gscramble\") readr::read_csv(csv) #> Rows: 13 Columns: 11 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \",\" #> chr (5): hap1, hap2, hpop1, hpop2, sample #> dbl (6): ind, par1, par2, ipar1, ipar2, osample #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #> # A tibble: 13 × 11 #>      ind  par1  par2 ipar1 ipar2 hap1  hap2  hpop1 hpop2 sample osample #>    <dbl> <dbl> <dbl> <dbl> <dbl> <chr> <chr> <chr> <chr> <chr>    <dbl> #>  1     1    NA    NA    NA    NA 1a    1b    A     A     NA          NA #>  2     2    NA    NA    NA    NA 2a    2b    A     A     NA          NA #>  3     3    NA    NA    NA    NA 3a    3b    B     B     NA          NA #>  4     4    NA    NA    NA    NA 4a    4b    A     A     NA          NA #>  5     5    NA    NA    NA    NA 5a    5b    B     B     NA          NA #>  6     6    NA    NA    NA    NA 6a    6b    B     B     NA          NA #>  7     7     2     3     2     2 NA    NA    NA    NA    s7           1 #>  8     8     4     5     2     2 NA    NA    NA    NA    s8           1 #>  9     9     1     7     1     1 NA    NA    NA    NA    NA          NA #> 10    10     7     8     1     1 NA    NA    NA    NA    s10          1 #> 11    11     8     6     1     1 NA    NA    NA    NA    NA          NA #> 12    12     9    11     2     2 NA    NA    NA    NA    s12          2 #> 13    13     1     6     1     1 NA    NA    NA    NA    s13          1"},{"path":"/articles/gscramble-tutorial.html","id":"a-four-poplation-gsp--gsp4","dir":"Articles","previous_headings":"Input Data","what":"A four-poplation GSP. gsp4","title":"A first tutorial for `gscramble`","text":"illustration, another pedigree represents F1 populations B mating F1 populations C D. tibble available package data object gsp4, CSV file available : looks like:","code":"system.file(\"extdata/gsp4.csv\", package = \"gscramble\")"},{"path":"/articles/gscramble-tutorial.html","id":"mapping-populationscollections-to-founding-populations--reppop","dir":"Articles","previous_headings":"Input Data","what":"Mapping populations/collections to founding populations. RepPop","title":"A first tutorial for `gscramble`","text":"create genomic simulation pedigree, typically denote populations founders come short names, like “” “B”. However, actual populations genotype data set might different. example, example data R package, groups individuals given I_meta. count many individuals groups/populations/clusters : must use tibble columns rep, pop, group, indicate founding populations (“”, “B”, etc.) correspond different groups (group column , example, I_meta) genotype data set. quite likely might wish iterate segregation procedure multiple times single simulation, can specify multiple “reps” (replicates) procedure. example might help. Suppose wish simulation pedigree GSP (13 individuals, 6 founders: 3 population “” 3 population “B”). first rep, might want map “” Pop1 “B” Pop2, second rep might want map “” Pop10, “B” Pop 5. (Note, point, genetic material 3 individuals populations “consumed” populations segregated, without replacement, samples genomic simulation pedigree.) RepPop tibble specify given package variable RepPop1: another example, imagine want three replicates creating admixed individuals sampled genomic permutation pedigree, gsp4. RepPop tibble might look like : Note request consume 1 individual populations 2, 3, 4, 10 (mapped , B, C, D, respectively), create 4 simulated, admixed, sampled individuals.","code":"I_meta %>%   count(group) #> # A tibble: 4 × 2 #>   group     n #>   <chr> <int> #> 1 Pop10    20 #> 2 Pop2     20 #> 3 Pop3     20 #> 4 Pop4     18 RepPop1 #> # A tibble: 4 × 3 #>     rep pop   group #>   <int> <chr> <chr> #> 1     1 A     Pop2  #> 2     1 B     Pop3  #> 3     2 A     Pop10 #> 4     2 B     Pop4 RepPop4 #> # A tibble: 12 × 3 #>      rep pop   group #>    <int> <chr> <chr> #>  1     1 A     Pop2  #>  2     1 B     Pop3  #>  3     1 C     Pop4  #>  4     1 D     Pop10 #>  5     2 A     Pop2  #>  6     2 B     Pop3  #>  7     2 C     Pop4  #>  8     2 D     Pop10 #>  9     3 A     Pop2  #> 10     3 B     Pop3  #> 11     3 C     Pop4  #> 12     3 D     Pop10"},{"path":"/articles/gscramble-tutorial.html","id":"segregating-chunks-of-genome-without-replacement","dir":"Articles","previous_headings":"","what":"Segregating Chunks of Genome Without Replacement","title":"A first tutorial for `gscramble`","text":"Now input data formats, can use segregate chunks chromosome. Note first part require genotypes. just simulating big chunks chromosome dropping pedigrees. function used segregate(). needed inputs : 1 genomic permuation pedigrees (like GSP gsp4) RepPop tibble go genomic permutation pedigree recombination probabilities, like RecRates. final wrinkle set can specify, single simulation, replicates multiple genomic permutation pedigrees can requested. done passing segregate() tibble list column named gpp holds genomic permutation pedigrees, parallel column named reppop holds RepPop tibbles genomic permutation pedigrees. Let’s see example, building two examples : segregation requested carried , using recombination rates RecRates like : output big tibble. row represents one segment genetic material amongst sampled individuals genomic permutation pedigrees. segment exists one samples (samp_index) sampled individual ped_sample_id given gpp (index giving row request input tibble) given rep within individual. , one two gametes (gamete_index) segregated individual, came certain founding population (pop_origin) corresponds named groups genotype file (group_origin). , course, segment occupies space start end chromosome chrom. Finally, index founder haplotype given gpp segement descended given rs_founder_haplotype short “rep-specific founder haplotype”. final piece information crucial segregating variation individuals Geno file onto segments. take next section, first look results . First, listing top Segments produced . table little wide, show first half columns second half . First half Second half","code":"Input_tibble <- tibble(   gpp = list(GSP, gsp4),   reppop = list(RepPop1, RepPop4) )  # here is what that input object looks like: Input_tibble #> # A tibble: 2 × 2 #>   gpp                reppop            #>   <list>             <list>            #> 1 <tibble [13 × 11]> <tibble [4 × 3]>  #> 2 <tibble [7 × 11]>  <tibble [12 × 3]> set.seed(15) # for reproducibility Segments <- segregate(   request = Input_tibble,   RR = RecRates ) Segments #> # A tibble: 286 × 14 #>    chrom_f   gpp   rep chrom ped_sample_id samp_index gamete_index #>    <fct>   <int> <int> <chr> <chr>              <int>        <dbl> #>  1 12          1     1 12    10                     1            1 #>  2 12          1     1 12    10                     1            1 #>  3 17          1     1 17    10                     1            1 #>  4 17          1     1 17    10                     1            1 #>  5 18          1     1 18    10                     1            1 #>  6 18          1     1 18    10                     1            1 #>  7 18          1     1 18    10                     1            1 #>  8 18          1     1 18    10                     1            1 #>  9 12          1     1 12    10                     1            2 #> 10 12          1     1 12    10                     1            2 #> # … with 276 more rows, and 7 more variables: gamete_segments <list>, #> #   pop_origin <chr>, rs_founder_haplo <int>, start <dbl>, end <dbl>, #> #   group_origin <chr>, sim_level_founder_haplo <int> Segments %>%   select(gpp:pop_origin) #> # A tibble: 286 × 8 #>      gpp   rep chrom ped_sample_id samp_index gamete_index gamete_segments #>    <int> <int> <chr> <chr>              <int>        <dbl> <list>          #>  1     1     1 12    10                     1            1 <dbl [3]>       #>  2     1     1 12    10                     1            1 <dbl [3]>       #>  3     1     1 17    10                     1            1 <dbl [3]>       #>  4     1     1 17    10                     1            1 <dbl [3]>       #>  5     1     1 18    10                     1            1 <dbl [5]>       #>  6     1     1 18    10                     1            1 <dbl [5]>       #>  7     1     1 18    10                     1            1 <dbl [5]>       #>  8     1     1 18    10                     1            1 <dbl [5]>       #>  9     1     1 12    10                     1            2 <dbl [5]>       #> 10     1     1 12    10                     1            2 <dbl [5]>       #> # … with 276 more rows, and 1 more variable: pop_origin <chr> Segments %>%   select(rs_founder_haplo:group_origin) #> # A tibble: 286 × 4 #>    rs_founder_haplo     start       end group_origin #>               <int>     <dbl>     <dbl> <chr>        #>  1                3        0   4888302. Pop2         #>  2                2  4888302. 63582536  Pop3         #>  3                2        0  64743108. Pop3         #>  4                4 64743108. 69302804  Pop2         #>  5                4        0   4583912. Pop2         #>  6                2  4583912.  9900731. Pop3         #>  7                4  9900731. 56967240. Pop2         #>  8                2 56967240. 61201108  Pop3         #>  9                6        0   9808646. Pop2         #> 10                4  9808646. 50453258. Pop3         #> # … with 276 more rows"},{"path":"/articles/gscramble-tutorial.html","id":"visualizing-those-chunks-of-genome","dir":"Articles","previous_headings":"Segregating Chunks of Genome Without Replacement","what":"Visualizing those chunks of genome","title":"A first tutorial for `gscramble`","text":"convenience function called plot_simulated_chromosome_segments() let’s quickly visualize results. Let’s try :","code":"g <- plot_simulated_chromomsome_segments(Segments, RecRates) g"},{"path":"/articles/gscramble-tutorial.html","id":"simulating-alleles-at-markers-within-segments","dir":"Articles","previous_headings":"","what":"Simulating alleles at markers within segments","title":"A first tutorial for `gscramble`","text":"separate steps required make happen, occur within function segments2markers(). steps happen : genotype matrix reorganized according group specification I_meta, individuals group adjacent one another genotype matrix. alleles carried individuals within population permuted. chromosomes carrying permuted alleles Geno mapped chromosomes carried founders simulation performed segregate(). alleles founder chromosomes propagated descendant segments individuals sampled GSP. Missing data dealt . (site one gene copy missing permutation mapping described , gene copy must declared missing, well). output genotypes formatted return, along information true admixture proportions individual. input segments2markers() : tibble segments, like returned segments(). variable Segments defined vignette example, individual meta data, marker meta data, genotype data. invoke like : output list three components: $ret_geno N x 2L matrix returned genotypes. two alleles locus two adjacent columns. $ret_ids: tibble IDs individuals corresponding rows ret_geno matrix. two columns: group indiv. first rows include samples GSP. group ped_hybs (meaning “sampled hybrids pedigree”) IDs indiv column format h- followed string replaced values : gpp-rep-ped_sample_id-samp_index-matrix_row. (need explaining): rep: ped: sample_id: samp_index: matrix_row: individual hybrid samples pedigree, rows remaining individuals whose genotypes permutation involved founders segregation simulation. given name permed + original IDs. group belongs group column. Things organized way whole genotype can easily passed ADMIXTURE admixture fractions hybrid individuals estimated using permed_* individuals samples known cluster/group origin. $hyb_Qs: tibble true admixture fraction (calculated total proportion genome length group) simulated hybrid.","code":"Markers <- segments2markers(   Segs = Segments,   Im = I_meta,   Mm = M_meta,   G = Geno ) dim(Markers$ret_geno) #> [1]  78 200 # genotypes of the first 10 individuals at the first 3 markers Markers$ret_geno[1:10, 1:6] #>       [,1] [,2] [,3] [,4] [,5] [,6] #>  [1,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  #>  [2,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  #>  [3,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  #>  [4,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  #>  [5,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  #>  [6,] \"G\"  \"G\"  \"C\"  \"C\"  \"C\"  \"T\"  #>  [7,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  #>  [8,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"C\"  #>  [9,] \"G\"  \"A\"  \"C\"  \"T\"  \"C\"  \"C\"  #> [10,] \"G\"  \"A\"  \"C\"  \"C\"  \"C\"  \"C\""},{"path":"/articles/gscramble-tutorial.html","id":"back-to-plink-format","dir":"Articles","previous_headings":"","what":"Back to plink format","title":"A first tutorial for `gscramble`","text":"","code":"tfile <- tempfile() gscramble2plink(   I_meta = Markers$ret_ids,   M_meta = M_meta,   Geno = Markers$ret_geno,   prefix = tfile ) #> pedfile written to /var/folders/xg/mz_qt7q54yv_hwzvhskwx2c00000gp/T//RtmpdvCZdV/file97b6e6aa676.ped #> mapfile written to /var/folders/xg/mz_qt7q54yv_hwzvhskwx2c00000gp/T//RtmpdvCZdV/file97b6e6aa676.map #> [1] TRUE"},{"path":"/articles/gscramble-tutorial_1.2.html","id":"input-data","dir":"Articles","previous_headings":"","what":"Input Data","title":"A first tutorial for `gscramble`","text":"gscramble operates diploid species. main functions gscramble require genetic data provided R objects (matrices/tibbles/etc.) particular formatting. describe formats objects . Later describe functions reading data PLINK format (perhaps others, future) necessary objects gscramble. main required objects (loosely aligning .bed/.fam/.bim file structure binary PLINK files) : matrix genotype data. (Geno) tibble meta data individuals genotype data (I_meta) tibble meta data markers genotype data (M_meta) top , want simulate hybrid individuals according pedigree, need provide tibble describes rates genetic recombination along chromosomes. (RecRates) tibble describes pedigree interest within sections chromosomes segregated successive generations, call “genome simulation pedigree” (GSP) tibble translates population specifiers pedigree (.e., GSP) population/group labels associated genetic data (.e., I_meta) different hybridization replicates (RepPop) Examples objects (heavily downsampled make small enough host CRAN, illustrating 78 individuals genotyped 100 loci distributed across 3 chromosomes [chr 12, 17, & 18] sampled 4 groups [Pop10, 2, 3, 4]) data set invasive feral swine (Smyser et al. 2020; full dataset: https://datadryad.org/stash/dataset/doi:10.5061%2Fdryad.jsxksn05z) included data objects package. following sections discuss data inputs detail.","code":""},{"path":"/articles/gscramble-tutorial_1.2.html","id":"matrix-of-genotype-data--geno","dir":"Articles","previous_headings":"Input Data","what":"Matrix of genotype data. Geno","title":"A first tutorial for `gscramble`","text":"genotype data must provided matrix. \\(N\\) individuals \\(L\\) loci diploid species, matrix \\(N\\) rows \\(2L\\) columns. locus gets two adjacent columns (one allele column) individual gets one row. example, first row first column Geno[1,1] first allele first locus first individual. first row second column Geno[1,2] second allele first locus first individual. first row third column Geno[1,3] first allele second locus first individual, . example data first 6 loci first 4 individuals package data Geno: data must stored character Matrix. Don’t pass matrix integers. alleles can characters whatsoever. allows data microsatellites, (\"112\", \"116\", etc), microhaplotypes (\"ACCGA\", \"ACCTC\", etc.), SNPs (\"\", \"C\", \"G\", \"T\"), etc. matrix integers, named, example IntMat, can coerce elements matrix characters without losing matrix shape data, : Missing genotype data must denoted standard R missing data specifier, NA. Don’t go around calling missing data \"-1\" expect work properly! Change \"-1\"’s NAs, regarded allelic type, rather missing data.missing data, let’s say denoted \"-1\", can change missing values NAs using following: Since \"-1\" NAs Geno dataset, nothing happens.","code":"Geno[1:4, 1:12] #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #> [1,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  \"A\"  \"A\"  \"G\"  \"G\"   \"T\"   \"T\"   #> [2,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  \"A\"  \"A\"  \"G\"  \"G\"   \"T\"   \"T\"   #> [3,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  \"A\"  \"A\"  \"G\"  \"G\"   \"T\"   \"T\"   #> [4,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  \"A\"  \"A\"  \"G\"  \"G\"   \"T\"   \"T\" storage.mode(IntMat) <- \"character\" Geno[Geno == \"-1\"]<-NA"},{"path":"/articles/gscramble-tutorial_1.2.html","id":"individual-meta-data--i_meta","dir":"Articles","previous_headings":"Input Data","what":"Individual meta data. I_meta","title":"A first tutorial for `gscramble`","text":"tibble gives information individuals whose genotypes Geno. can many different columns want , must least two columns: group: column gives character name group/cluster/population individual considered part . indiv: column gives character ID individual. number rows tibble exactly equal number rows Geno order individuals I_meta must correspond exactly order individuals Geno. first rows example data’s I_meta look like:","code":"head(I_meta) #> # A tibble: 6 × 2 #>   group indiv     #>   <chr> <chr>     #> 1 Pop2  ID0033692 #> 2 Pop2  ID0014942 #> 3 Pop2  ID0014961 #> 4 Pop2  ID0016971 #> 5 Pop2  ID0016972 #> 6 Pop2  ID0017013"},{"path":"/articles/gscramble-tutorial_1.2.html","id":"marker-meta-data--m_meta","dir":"Articles","previous_headings":"Input Data","what":"Marker meta data. M_meta","title":"A first tutorial for `gscramble`","text":"input tibble information markers Geno matrix. can variety columns , required three: chrom: character name chromosome upon marker occurs. example, \"1\", \"X\" \"Omy28\", illustrated M_meta chr12, chr17, chr18.Importantly, simulating physical linkage recombination, names chromosomes file must correspond exactly names chromosomes RecRates (see next section). pos: numeric (integer double) column giving position marker (typically base pairs, arbitrary units correspond position units RecRates), along chromosome. position values must greater 0. variant_id: character vector unique ID names markers. globally unique, .e., don’t two markers different chromosomes named thing. must exactly half many rows M_meta columns Geno, order markers M_meta must correspond exactly order markers columns Geno. first rows example data M_meta:","code":"head(M_meta) #> # A tibble: 6 × 3 #>   chrom      pos variant_id          #>   <chr>    <dbl> <chr>               #> 1 12     4469057 WU_10.2_12_4469057  #> 2 12     5238225 ALGA0064411         #> 3 12     7394362 WU_10.2_12_7394362  #> 4 12     7651064 ASGA0090707         #> 5 12     8971475 WU_10.2_12_8971475  #> 6 12    11034660 WU_10.2_12_11034660"},{"path":"/articles/gscramble-tutorial_1.2.html","id":"recombination-rates--recrates","dir":"Articles","previous_headings":"Input Data","what":"Recombination rates. RecRates","title":"A first tutorial for `gscramble`","text":"tibble gives information rate recombinations genome. necessary simulating linked markers. required gscramble know crossover rate recombination rate every adjacent pair markers (though information, can provide RecRates, [see ]). Rather, rate recombination can specified terms per-meiosis probability recombination number (preferably relatively short—example, one megabase less) bins. RecRates tibble required four columns: chrom: chromosome bin occurs. Note chromosome nomenclature must match exactly used M_meta. chrom_len: length chromosome. Yes, value chromosome typically duplicated row occupied chrom. start_pos: starting position bin. typically position along chromosome base pairs, though position can units, long corresponds position used M_meta. end_pos: ending position bin. rec_prob: per-meiosis probability recombination occurring bin. important notes: start point bin 1 greater end point preceding bin. positions markers (M_meta) included amongst bin intervals defined start_pos end_pos. crucially regard, smallest start_pos less smallest pos M_meta greatest end_pos greater equal largest pos M_meta. Otherwise, recombination might never possible pairs markers data set. chromosome length chrom_len must exceed position every marker chromosome M_meta. case possible markers dropped data set, possibly unexpected bad results. can check errors regard using function check_chrom_lengths().","code":"head(RecRates) #> # A tibble: 6 × 5 #>   chrom chrom_len start_pos end_pos rec_prob #>   <chr>     <dbl>     <dbl>   <dbl>    <dbl> #> 1 12     63582536         1   79501 0.000694 #> 2 12     63582536     79502 1573908 0.00131  #> 3 12     63582536   1573909 2097503 0.000554 #> 4 12     63582536   2097504 3308663 0.00557  #> 5 12     63582536   3308664 4021031 0.0179   #> 6 12     63582536   4021032 5026780 0.0115"},{"path":"/articles/gscramble-tutorial_1.2.html","id":"genome-simulation-pedigree--gsp","dir":"Articles","previous_headings":"Input Data","what":"Genome Simulation Pedigree. GSP","title":"A first tutorial for `gscramble`","text":"GSP specification pedigree within sections chromosome get segregated across successive generations represented within pedigree used guide sampling chromosomal sections without replacement. allow us characterize/simulate hybrid individuals purpose assessing power classify individuals hybrid classes interest (.e., F1s, F1BC1s, F2BC1s, etc.). GSP must tibble individual numeric identifier (1 number individuals pedigree). Founders listed directly (1…nFounders) whereas numbers can represent one individual successive generations (e.g., two F1 individuals sampled within basic pedigree illustrated characterized ‘3’). founders’ parents listed NA non-founders parents listed. Founders’ haplotypes must unique IDs must originate specified population (typically given capital letters.) Individuals can sampled individuals pedigree, user indicate many gametes must segregated individual (two parents) order consume genetic material present among founders. probably sounds little abstract, , indeed, . gscramble includes 15 basic GSPs (illustrated within object GSP_opts) can retreived specifying types individuals interest function create_GSP(). illustrate , restricted GSP configurations. 15 specific GSP configurations interest authors included illustrate structure GSP tibbles may interest . try explain GSP concept fully, first draw picture basic pedigree (simulation F1s created hybridization individuals two population). show tibble representation GSP discuss structure GSP light two pieces information.  Now, example, let’s say interested simulating F1 hybrids pairwise combinations populations (example data Pop1, Pop2, Pop3, Pop4). F1s symmetrical Pop1-Pop2 hybrid identical Pop2-Pop1 hybrid. Accordingly, need specify RepPop tibble define populations use replicate simulation: Next, need define GSP using ‘p1’ ‘p2’ RepPop represent Pop1 Pop2. Building upon simplistic GSP, let’s build something little ‘complex’ F1s, F1BC1s, F1BC2s using built-function create_GSP(). example, Pop1 population interest. simulating Pop1-Pop2 F1s, pairing F1 individuals Pop1 generate backcrossed hybrids, different Pop1-Pop2, backcrossed Pop2 hybrids. picture looks like:  Notice backcrossed individuals symmetrical. Now say can simulate hybrid individuals Pop1 populations using RepPop file. interested Pop1-Pop2, backcrossed Pop2 hybrids can use RepPop file looks like : go examples define populations RepPop section “Mapping populations/collections founding populations. RepPop” tutorial. previous examples, specified initial suite GSPs interest, combining various configurations F1s, F2s, F1BC1s, F1BC2s using create_GSP() function. However, limited GSPs may create . two illustrations complex patterns hybridization: package data object GSP shows example genome simulation pedigree 13 members. picture looks like:  can produce type plot using gsp2dot() function ‘gscramble’ package, requires installation GraphViz dot software. tibble specification GSP printed :","code":"Pattern = c(\"Pop1\", \"Pop2\", \"Pop1\", \"Pop3\", \"Pop1\", \"Pop4\", \"Pop2\", \"Pop3\", \"Pop2\", \"Pop4\", \"Pop3\", \"Pop1\") RepPopF1 <- as_tibble(data.frame(rep = rep(1:6, times = 1, each = 2),                                  pop = rep(c(\"p1\", \"p2\"), times = 6), group = Pattern)) head(RepPopF1) #> # A tibble: 6 × 3 #>     rep pop   group #>   <int> <chr> <chr> #> 1     1 p1    Pop1  #> 2     1 p2    Pop2  #> 3     2 p1    Pop1  #> 4     2 p2    Pop3  #> 5     3 p1    Pop1  #> 6     3 p2    Pop4 gspF1 <- create_GSP(pop1 = \"p1\", pop2 = \"p2\", F1 = TRUE)  gspF1 #> # A tibble: 3 × 11 #>     ind  par1  par2 ipar1 ipar2 hap1  hap2  hpop1 hpop2 sample osample #>   <dbl> <dbl> <dbl> <dbl> <dbl> <chr> <chr> <chr> <chr> <chr>    <dbl> #> 1     1    NA    NA    NA    NA 1a    1b    p1    p1    NA          NA #> 2     2    NA    NA    NA    NA 2a    2b    p2    p2    NA          NA #> 3     3     1     2     2     2 NA    NA    NA    NA    s3           2 gspComplex <- create_GSP(pop1 = \"p1\", pop2 = \"p2\", F1 = TRUE, F1B = TRUE, F1B2 = TRUE)  gspComplex #> # A tibble: 7 × 11 #>     ind  par1  par2 ipar1 ipar2 hap1  hap2  hpop1 hpop2 sample osample #>   <dbl> <dbl> <dbl> <dbl> <dbl> <chr> <chr> <chr> <chr> <chr>    <dbl> #> 1     1    NA    NA    NA    NA 1a    1b    p1    p1    NA          NA #> 2     2    NA    NA    NA    NA 2a    2b    p1    p1    NA          NA #> 3     3    NA    NA    NA    NA 3a    3b    p1    p1    NA          NA #> 4     4    NA    NA    NA    NA 4a    4b    p2    p2    NA          NA #> 5     5     1     4     2     2 NA    NA    NA    NA    s5           1 #> 6     6     2     5     2     2 NA    NA    NA    NA    s6           1 #> 7     7     3     6     2     2 NA    NA    NA    NA    s7           2 Pattern = c(\"Pop1\", \"Pop2\", \"Pop1\", \"Pop3\", \"Pop1\", \"Pop4\") RepPopComplex <- as_tibble(data.frame(rep = rep(1:3, times = 1, each = 2),                                  pop = rep(c(\"p1\", \"p2\"), times = 3), group = Pattern)) RepPopComplex #> # A tibble: 6 × 3 #>     rep pop   group #>   <int> <chr> <chr> #> 1     1 p1    Pop1  #> 2     1 p2    Pop2  #> 3     2 p1    Pop1  #> 4     2 p2    Pop3  #> 5     3 p1    Pop1  #> 6     3 p2    Pop4 Pattern = c(\"Pop2\", \"Pop1\", \"Pop3\", \"Pop1\", \"Pop4\", \"Pop1\") RepPopComplex2 <- as_tibble(data.frame(rep = rep(1:3, times = 1, each = 2),                                  pop = rep(c(\"p1\", \"p2\"), times = 3), group = Pattern)) RepPopComplex2 #> # A tibble: 6 × 3 #>     rep pop   group #>   <int> <chr> <chr> #> 1     1 p1    Pop2  #> 2     1 p2    Pop1  #> 3     2 p1    Pop3  #> 4     2 p2    Pop1  #> 5     3 p1    Pop4  #> 6     3 p2    Pop1 csv <- system.file(\"extdata/13-member-ped.csv\", package = \"gscramble\") gsp_tib <- readr::read_csv(csv) paths <- gsp2dot(g = gsp_tib, path = \"images/13-member-ped\") # now, get rid of the dot and png files file.remove(paths[1:2]) csv <- system.file(\"extdata/13-member-ped.csv\", package = \"gscramble\") readr::read_csv(csv) #> Rows: 13 Columns: 11 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \",\" #> chr (5): hap1, hap2, hpop1, hpop2, sample #> dbl (6): ind, par1, par2, ipar1, ipar2, osample #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #> # A tibble: 13 × 11 #>      ind  par1  par2 ipar1 ipar2 hap1  hap2  hpop1 hpop2 sample osample #>    <dbl> <dbl> <dbl> <dbl> <dbl> <chr> <chr> <chr> <chr> <chr>    <dbl> #>  1     1    NA    NA    NA    NA 1a    1b    A     A     NA          NA #>  2     2    NA    NA    NA    NA 2a    2b    A     A     NA          NA #>  3     3    NA    NA    NA    NA 3a    3b    B     B     NA          NA #>  4     4    NA    NA    NA    NA 4a    4b    A     A     NA          NA #>  5     5    NA    NA    NA    NA 5a    5b    B     B     NA          NA #>  6     6    NA    NA    NA    NA 6a    6b    B     B     NA          NA #>  7     7     2     3     2     2 NA    NA    NA    NA    s7           1 #>  8     8     4     5     2     2 NA    NA    NA    NA    s8           1 #>  9     9     1     7     1     1 NA    NA    NA    NA    NA          NA #> 10    10     7     8     1     1 NA    NA    NA    NA    s10          1 #> 11    11     8     6     1     1 NA    NA    NA    NA    NA          NA #> 12    12     9    11     2     2 NA    NA    NA    NA    s12          2 #> 13    13     1     6     1     1 NA    NA    NA    NA    s13          1"},{"path":"/articles/gscramble-tutorial_1.2.html","id":"a-four-poplation-gsp--gsp4","dir":"Articles","previous_headings":"Input Data","what":"A four-poplation GSP. gsp4","title":"A first tutorial for `gscramble`","text":", alternatively, let’s say interested patterns hybridization restricted simply two populations. illustration, another pedigree represents F1 populations B mating F1 populations C D. tibble available package data object gsp4, CSV file available : looks like:","code":"system.file(\"extdata/gsp4.csv\", package = \"gscramble\")"},{"path":"/articles/gscramble-tutorial_1.2.html","id":"mapping-populationscollections-to-founding-populations--reppop","dir":"Articles","previous_headings":"Input Data","what":"Mapping populations/collections to founding populations. RepPop","title":"A first tutorial for `gscramble`","text":"create genomic simulation pedigree, typically denote populations founders come short names, like “” “B”. However, actual populations genotype data set might different. example, example data R package, groups individuals given I_meta. count many individuals groups/populations/clusters : must use tibble columns rep, pop, group, indicate founding populations (“”, “B”, etc.) correspond different groups (group column , example, I_meta) genotype data set. quite likely might wish iterate segregation procedure multiple times single simulation, can specify multiple “reps” (replicates) procedure. example might help. Suppose wish simulation pedigree GSP (13 individuals, 6 founders: 3 population “” 3 population “B”). first rep, might want map “” Pop2 “B” Pop3, second rep might want map “” Pop1, “B” Pop 4. (Note, point, genetic material 3 individuals populations “consumed” populations segregated, without replacement, samples genomic simulation pedigree.) RepPop tibble specify given package variable RepPop1: another example, imagine want three replicates creating admixed individuals sampled genomic permutation pedigree, gsp4. RepPop tibble might look like : Note request consume 1 individual populations 2, 3, 4, 10 (mapped , B, C, D, respectively), create 4 simulated, admixed, sampled individuals.","code":"I_meta %>%   count(group) #> # A tibble: 4 × 2 #>   group     n #>   <chr> <int> #> 1 Pop10    20 #> 2 Pop2     20 #> 3 Pop3     20 #> 4 Pop4     18 RepPop1 #> # A tibble: 4 × 3 #>     rep pop   group #>   <int> <chr> <chr> #> 1     1 A     Pop2  #> 2     1 B     Pop3  #> 3     2 A     Pop10 #> 4     2 B     Pop4 RepPop4 #> # A tibble: 12 × 3 #>      rep pop   group #>    <int> <chr> <chr> #>  1     1 A     Pop2  #>  2     1 B     Pop3  #>  3     1 C     Pop4  #>  4     1 D     Pop10 #>  5     2 A     Pop2  #>  6     2 B     Pop3  #>  7     2 C     Pop4  #>  8     2 D     Pop10 #>  9     3 A     Pop2  #> 10     3 B     Pop3  #> 11     3 C     Pop4  #> 12     3 D     Pop10"},{"path":"/articles/gscramble-tutorial_1.2.html","id":"segregating-chunks-of-genome-without-replacement","dir":"Articles","previous_headings":"","what":"Segregating Chunks of Genome Without Replacement","title":"A first tutorial for `gscramble`","text":"Now input data formats, can use segregate chunks chromosome. Note first part require genotypes. just simulating big chunks chromosome dropping pedigrees. function used segregate(). needed inputs : 1 genomic permuation pedigrees (like GSP gsp4) RepPop tibble go genomic permutation pedigree recombination probabilities, like RecRates. final wrinkle set can specify, single simulation, replicates multiple genomic permutation pedigrees can requested. done passing segregate() tibble list column named gpp holds genomic permutation pedigrees, parallel column named reppop holds RepPop tibbles genomic permutation pedigrees. Let’s see example, building two examples : segregation requested carried , using recombination rates RecRates like : output big tibble. row represents one segment genetic material amongst sampled individuals genomic permutation pedigrees. segment exists one samples (samp_index) sampled individual ped_sample_id given gpp (index giving row request input tibble) given rep within individual. , one two gametes (gamete_index) segregated individual, came certain founding population (pop_origin) corresponds named groups genotype file (group_origin). , course, segment occupies space start end chromosome chrom. Finally, index founder haplotype given gpp segement descended given rs_founder_haplotype short “rep-specific founder haplotype”. final piece information crucial segregating variation individuals Geno file onto segments. take next section, first look results . First, listing top Segments produced . table little wide, show first half columns second half . First half Second half","code":"Input_tibble <- tibble(   gpp = list(GSP, gsp4),   reppop = list(RepPop1, RepPop4) )  # here is what that input object looks like: Input_tibble #> # A tibble: 2 × 2 #>   gpp                reppop            #>   <list>             <list>            #> 1 <tibble [13 × 11]> <tibble [4 × 3]>  #> 2 <tibble [7 × 11]>  <tibble [12 × 3]> set.seed(15) # for reproducibility Segments <- segregate(   request = Input_tibble,   RR = RecRates ) Segments #> # A tibble: 286 × 14 #>    chrom_f   gpp   rep chrom ped_sample_id samp_index gamete_index #>    <fct>   <int> <int> <chr> <chr>              <int>        <dbl> #>  1 12          1     1 12    10                     1            1 #>  2 12          1     1 12    10                     1            1 #>  3 17          1     1 17    10                     1            1 #>  4 17          1     1 17    10                     1            1 #>  5 18          1     1 18    10                     1            1 #>  6 18          1     1 18    10                     1            1 #>  7 18          1     1 18    10                     1            1 #>  8 18          1     1 18    10                     1            1 #>  9 12          1     1 12    10                     1            2 #> 10 12          1     1 12    10                     1            2 #> # … with 276 more rows, and 7 more variables: gamete_segments <list>, #> #   pop_origin <chr>, rs_founder_haplo <int>, start <dbl>, end <dbl>, #> #   group_origin <chr>, sim_level_founder_haplo <int> Segments %>%   select(gpp:pop_origin) #> # A tibble: 286 × 8 #>      gpp   rep chrom ped_sample_id samp_index gamete_index gamete_segments #>    <int> <int> <chr> <chr>              <int>        <dbl> <list>          #>  1     1     1 12    10                     1            1 <dbl [3]>       #>  2     1     1 12    10                     1            1 <dbl [3]>       #>  3     1     1 17    10                     1            1 <dbl [3]>       #>  4     1     1 17    10                     1            1 <dbl [3]>       #>  5     1     1 18    10                     1            1 <dbl [5]>       #>  6     1     1 18    10                     1            1 <dbl [5]>       #>  7     1     1 18    10                     1            1 <dbl [5]>       #>  8     1     1 18    10                     1            1 <dbl [5]>       #>  9     1     1 12    10                     1            2 <dbl [5]>       #> 10     1     1 12    10                     1            2 <dbl [5]>       #> # … with 276 more rows, and 1 more variable: pop_origin <chr> Segments %>%   select(rs_founder_haplo:group_origin) #> # A tibble: 286 × 4 #>    rs_founder_haplo     start       end group_origin #>               <int>     <dbl>     <dbl> <chr>        #>  1                3        0   4888302. Pop2         #>  2                2  4888302. 63582536  Pop3         #>  3                2        0  64743108. Pop3         #>  4                4 64743108. 69302804  Pop2         #>  5                4        0   4583912. Pop2         #>  6                2  4583912.  9900731. Pop3         #>  7                4  9900731. 56967240. Pop2         #>  8                2 56967240. 61201108  Pop3         #>  9                6        0   9808646. Pop2         #> 10                4  9808646. 50453258. Pop3         #> # … with 276 more rows"},{"path":"/articles/gscramble-tutorial_1.2.html","id":"visualizing-those-chunks-of-genome","dir":"Articles","previous_headings":"Segregating Chunks of Genome Without Replacement","what":"Visualizing those chunks of genome","title":"A first tutorial for `gscramble`","text":"convenience function called plot_simulated_chromosome_segments() let’s quickly visualize results. Let’s try :","code":"g <- plot_simulated_chromomsome_segments(Segments, RecRates) g"},{"path":"/articles/gscramble-tutorial_1.2.html","id":"simulating-alleles-at-markers-within-segments","dir":"Articles","previous_headings":"","what":"Simulating alleles at markers within segments","title":"A first tutorial for `gscramble`","text":"separate steps required make happen, occur within function segments2markers(). steps happen : genotype matrix reorganized according group specification I_meta, individuals group adjacent one another genotype matrix. alleles carried individuals within population permuted. chromosomes carrying permuted alleles Geno mapped chromosomes carried founders simulation performed segregate(). alleles founder chromosomes propagated descendant segments individuals sampled GSP. Missing data dealt . (site one gene copy missing permutation mapping described , gene copy must declared missing, well). output genotypes formatted return, along information true admixture proportions individual. input segments2markers() : tibble segments, like returned segments(). variable Segments defined vignette example, individual meta data, marker meta data, genotype data. invoke like : output list three components: $ret_geno N x 2L matrix returned genotypes. two alleles locus two adjacent columns. $ret_ids: tibble IDs individuals corresponding rows ret_geno matrix. two columns: group indiv. first rows include samples GSP. group ped_hybs (meaning “sampled hybrids pedigree”) IDs indiv column format h- followed string replaced values : gpp-rep-ped_sample_id-samp_index-matrix_row. (need explaining): rep: ped: sample_id: samp_index: matrix_row: individual hybrid samples pedigree, rows remaining individuals whose genotypes permutation involved founders segregation simulation. given name permed + original IDs. group belongs group column. Things organized way whole genotype can easily passed ADMIXTURE admixture fractions hybrid individuals estimated using permed_* individuals samples known cluster/group origin. $hyb_Qs: tibble true admixture fraction (calculated total proportion genome length group) simulated hybrid.","code":"Markers <- segments2markers(   Segs = Segments,   Im = I_meta,   Mm = M_meta,   G = Geno ) dim(Markers$ret_geno) #> [1]  78 200 # genotypes of the first 10 individuals at the first 3 markers Markers$ret_geno[1:10, 1:6] #>       [,1] [,2] [,3] [,4] [,5] [,6] #>  [1,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  #>  [2,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  #>  [3,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  #>  [4,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  #>  [5,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  #>  [6,] \"G\"  \"G\"  \"C\"  \"C\"  \"C\"  \"T\"  #>  [7,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"T\"  #>  [8,] \"G\"  \"G\"  \"C\"  \"C\"  \"T\"  \"C\"  #>  [9,] \"G\"  \"A\"  \"C\"  \"T\"  \"C\"  \"C\"  #> [10,] \"G\"  \"A\"  \"C\"  \"C\"  \"C\"  \"C\""},{"path":"/articles/gscramble-tutorial_1.2.html","id":"back-to-plink-format","dir":"Articles","previous_headings":"","what":"Back to plink format","title":"A first tutorial for `gscramble`","text":"","code":"tfile <- tempfile() gscramble2plink(   I_meta = Markers$ret_ids,   M_meta = M_meta,   Geno = Markers$ret_geno,   prefix = tfile ) #> pedfile written to /var/folders/xg/mz_qt7q54yv_hwzvhskwx2c00000gp/T//Rtmp2FbQUZ/file9a27d0b036.ped #> mapfile written to /var/folders/xg/mz_qt7q54yv_hwzvhskwx2c00000gp/T//Rtmp2FbQUZ/file9a27d0b036.map #> [1] TRUE"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"package maintainer. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ww (2022). gscramble: Package (Title Case). R package version 0.1.0.","code":"@Manual{,   title = {gscramble: What the Package Does (Title Case)},   author = {Who wrote it},   year = {2022},   note = {R package version 0.1.0}, }"},{"path":"/index.html","id":"gscramble","dir":"","previous_headings":"","what":"What the Package Does (Title Case)","title":"What the Package Does (Title Case)","text":"R package development. can install GitHub: installed can read vignettes:","code":"devtools::install_github(\"eriqande/gscramble\", build_opts = c(\"--no-resave-data\")) vignette(\"gscramble-tutorial\")  # information on input data objects vignette(\"gscramble-data-in-out\")  # not yet written (reading/writing to PLINK, etc.)"},{"path":"/reference/GSP.html","id":null,"dir":"Reference","previous_headings":"","what":"Tibble holding specification for a 13 member genomic simulation pedigree — GSP","title":"Tibble holding specification for a 13 member genomic simulation pedigree — GSP","text":"CSV version extdata/13-member-ped.csv.","code":""},{"path":"/reference/GSP.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Tibble holding specification for a 13 member genomic simulation pedigree — GSP","text":"tibble","code":""},{"path":"/reference/GSP.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Tibble holding specification for a 13 member genomic simulation pedigree — GSP","text":"just made !","code":""},{"path":"/reference/GSP.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tibble holding specification for a 13 member genomic simulation pedigree — GSP","text":"Need document little ....","code":""},{"path":"/reference/GSP_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Tibble holding specification for a 5 member genomic permutation pedigree. — GSP_opts","title":"Tibble holding specification for a 5 member genomic permutation pedigree. — GSP_opts","text":"3 founders","code":""},{"path":"/reference/GSP_opts.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Tibble holding specification for a 5 member genomic permutation pedigree. — GSP_opts","text":"list 15 tibbles","code":""},{"path":"/reference/GSP_opts.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Tibble holding specification for a 5 member genomic permutation pedigree. — GSP_opts","text":"Rachael Tim","code":""},{"path":"/reference/GSP_opts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tibble holding specification for a 5 member genomic permutation pedigree. — GSP_opts","text":"Need document little ....","code":""},{"path":"/reference/Geno.html","id":null,"dir":"Reference","previous_headings":"","what":"Genotype matrix of 78 individuals and 100 SNP markers — Geno","title":"Genotype matrix of 78 individuals and 100 SNP markers — Geno","text":"dataset represents 3 distinct populations feral swine United States. make dataset computationally efficient, 3 chromosomes (12, 17, 18) pig genome used. , loci reduced 100 informative loci distinguishing 3 populations. genotype matrix standard \"two-column\" format genotype data matrix diploid species two adjacent columns make locus column locus contains allele. Genotype data stored character class. Missing data represented NAs. Individual IDs population assignment can found I_meta Locus chromosome information genotypes can found M_meta","code":""},{"path":"/reference/Geno.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Genotype matrix of 78 individuals and 100 SNP markers — Geno","text":"character matrix.row represents individual ","code":""},{"path":"/reference/Geno.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Genotype matrix of 78 individuals and 100 SNP markers — Geno","text":"Must add...","code":""},{"path":"/reference/Geno.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Genotype matrix of 78 individuals and 100 SNP markers — Geno","text":"Need document little ....","code":""},{"path":"/reference/I_meta.html","id":null,"dir":"Reference","previous_headings":"","what":"Meta data for 329 individuals — I_meta","title":"Meta data for 329 individuals — I_meta","text":"Individuals IDs group specifications 329 individuals whose genotypes Geno","code":""},{"path":"/reference/I_meta.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Meta data for 329 individuals — I_meta","text":"tibble three columns: chrom, pos, variant_id.","code":""},{"path":"/reference/I_meta.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Meta data for 329 individuals — I_meta","text":"Must add...","code":""},{"path":"/reference/M_meta.html","id":null,"dir":"Reference","previous_headings":"","what":"Meta data for 25165 molecular markers — M_meta","title":"Meta data for 25165 molecular markers — M_meta","text":"Chromosome, position, ID 25156 molecular markers Geno","code":""},{"path":"/reference/M_meta.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Meta data for 25165 molecular markers — M_meta","text":"tibble two columns: group indiv.","code":""},{"path":"/reference/M_meta.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Meta data for 25165 molecular markers — M_meta","text":"Must add...","code":""},{"path":"/reference/RecRates.html","id":null,"dir":"Reference","previous_headings":"","what":"Recombination rate data for many roughly 1 Mb bins — RecRates","title":"Recombination rate data for many roughly 1 Mb bins — RecRates","text":"Chromosome, start position end position probability recombination within bin chromosomes pigs.","code":""},{"path":"/reference/RecRates.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Recombination rate data for many roughly 1 Mb bins — RecRates","text":"tibble four columns: chrom, chrom_len, start_pos, end_pos, rec_prob.","code":""},{"path":"/reference/RecRates.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Recombination rate data for many roughly 1 Mb bins — RecRates","text":"Must add, inluding computed Torterau.","code":""},{"path":"/reference/RepPop1.html","id":null,"dir":"Reference","previous_headings":"","what":"A reppop tibble for an example — RepPop1","title":"A reppop tibble for an example — RepPop1","text":"Needs explanation","code":""},{"path":"/reference/RepPop1.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A reppop tibble for an example — RepPop1","text":"tibble...","code":""},{"path":"/reference/RepPop1.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"A reppop tibble for an example — RepPop1","text":"eric","code":""},{"path":"/reference/RepPop4.html","id":null,"dir":"Reference","previous_headings":"","what":"A reppop tibble for an example — RepPop4","title":"A reppop tibble for an example — RepPop4","text":"Needs explanation","code":""},{"path":"/reference/RepPop4.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A reppop tibble for an example — RepPop4","text":"tibble...","code":""},{"path":"/reference/RepPop4.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"A reppop tibble for an example — RepPop4","text":"eric","code":""},{"path":"/reference/big_wrapper.html","id":null,"dir":"Reference","previous_headings":"","what":"Just a big, messy wrapper to wrap up some things so Tim can use them — big_wrapper","title":"Just a big, messy wrapper to wrap up some things so Tim can use them — big_wrapper","text":"Just big, messy wrapper wrap things Tim can use ","code":""},{"path":"/reference/big_wrapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Just a big, messy wrapper to wrap up some things so Tim can use them — big_wrapper","text":"","code":"big_wrapper(GS_input, Segs, M_meta)"},{"path":"/reference/big_wrapper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Just a big, messy wrapper to wrap up some things so Tim can use them — big_wrapper","text":"GS_input rearranged (yet scrambled) genos Segs simulated segments M_meta marker meta data","code":""},{"path":"/reference/check_chrom_lengths.html","id":null,"dir":"Reference","previous_headings":"","what":"check that the chromosome lengths are acceptable given recombination rates — check_chrom_lengths","title":"check that the chromosome lengths are acceptable given recombination rates — check_chrom_lengths","text":"gscramble work properly, variant positions chromosome (found meta data file) must equal less total chromosome length found recombination map. words, variant positions must within total length chromosome. check_chrom_lengths() function checks variant positions chromosome exceed total chromosome length recombination map. Input files function include 1) meta data file contains 3 columns (chromosome ID character, position variant numeric, name variant character) 2) recombination map contains 5 columns (chromosome ID character, total length chromosome numeric, starting position recombination bin numeric, last position recombination bin numeric, recombination probability given bin numeric).","code":""},{"path":"/reference/check_chrom_lengths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check that the chromosome lengths are acceptable given recombination rates — check_chrom_lengths","text":"","code":"check_chrom_lengths(meta, rec)"},{"path":"/reference/check_chrom_lengths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"check that the chromosome lengths are acceptable given recombination rates — check_chrom_lengths","text":"meta tibble meta data genotype data. must consist columns (chrom, pos, variant_id). rec tibble recombination map information study species.must contain 5 columns (chrom, chrom_len, start_pos, end_pos, rec_prob).","code":""},{"path":"/reference/check_chrom_lengths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"check that the chromosome lengths are acceptable given recombination rates — check_chrom_lengths","text":"function return message chromosome stating whether chromosome lengths accurate","code":""},{"path":"/reference/check_chrom_lengths.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"check that the chromosome lengths are acceptable given recombination rates — check_chrom_lengths","text":"","code":"# The example uses the built in datasets M_meta and RecRates # to use the check_chrom_lengths() function  check_chrom_lengths(M_meta,RecRates) #> [1] \"The length of chromosome  12  is formatted properly\" #> [1] \"The length of chromosome  17  is formatted properly\" #> [1] \"The length of chromosome  18  is formatted properly\""},{"path":"/reference/check_gsp_for_validity_and_saturation.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that GSP does not reuse genetic material and yet uses all of it — check_gsp_for_validity_and_saturation","title":"Check that GSP does not reuse genetic material and yet uses all of it — check_gsp_for_validity_and_saturation","text":"conditions can checked GSP inbreeding loops simply ensuring amount genetic material coming individual amount going (either segregated gametes samples).  amount material coming individual GSP greater amount coming , error thrown.  amount coming less amount coming , warning GSP thrown. Messages printed via message() warning() indicate individuals GSP problematic.  problematic individuals listed error thrown stop().","code":""},{"path":"/reference/check_gsp_for_validity_and_saturation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that GSP does not reuse genetic material and yet uses all of it — check_gsp_for_validity_and_saturation","text":"","code":"check_gsp_for_validity_and_saturation(GP)"},{"path":"/reference/check_gsp_for_validity_and_saturation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that GSP does not reuse genetic material and yet uses all of it — check_gsp_for_validity_and_saturation","text":"GP gsp list format produced function prep_gsp_for_hap_dropping().  See documentation return object prep_gsp_for_hap_dropping() description.","code":""},{"path":"/reference/check_gsp_for_validity_and_saturation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that GSP does not reuse genetic material and yet uses all of it — check_gsp_for_validity_and_saturation","text":"function return anything.","code":""},{"path":"/reference/check_gsp_for_validity_and_saturation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that GSP does not reuse genetic material and yet uses all of it — check_gsp_for_validity_and_saturation","text":"","code":"# get the 13 member pedigree in tibble form as the package # and turn it into a list GP <- prep_gsp_for_hap_dropping(GSP)  # check it. (This passes) check_gsp_for_validity_and_saturation(GP)  if (FALSE) { # Read in a gsp with errors and then make sure all the # error in it are caught bad <- readr::read_csv(\"inst/extdata/13-member-ped-with-errors.csv\")  # check_gsp_for_validity_and_saturation() is called internally from # within prep_gsp_for_hap_dropping(), after creating a list-from GSP. # This will show the error produced by check_gsp_for_validity_and_saturation(). badL <- prep_gsp_for_hap_dropping(bad) }"},{"path":"/reference/check_pedigree_for_inbreeding.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the a GSP (in prepped list format) for inbreeding loops — check_pedigree_for_inbreeding","title":"Check the a GSP (in prepped list format) for inbreeding loops — check_pedigree_for_inbreeding","text":"GSP passed prep_gsp_for_hap_dropping() list format individuals ordered way easy check inbreeding loops (allowed!).  version uses simple recursive approach compute ancestry vector individual, detects inbreeding occurrence ID ancestry vector .  might slow large pedigrees, people use, fine.","code":""},{"path":"/reference/check_pedigree_for_inbreeding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the a GSP (in prepped list format) for inbreeding loops — check_pedigree_for_inbreeding","text":"","code":"check_pedigree_for_inbreeding(GP)"},{"path":"/reference/check_pedigree_for_inbreeding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the a GSP (in prepped list format) for inbreeding loops — check_pedigree_for_inbreeding","text":"GP gsp list format produced function prep_gsp_for_hap_dropping().  See documentation return object prep_gsp_for_hap_dropping() description.","code":""},{"path":"/reference/check_pedigree_for_inbreeding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the a GSP (in prepped list format) for inbreeding loops — check_pedigree_for_inbreeding","text":"function return anything.  throws error via stop() inbreeeding loops found pedigree.  throwing error lists individuals repeated occurrences ancestry vectors via message() function.","code":""},{"path":"/reference/check_pedigree_for_inbreeding.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check the a GSP (in prepped list format) for inbreeding loops — check_pedigree_for_inbreeding","text":"Note ancestry vector produced ordered way ancestry vectors package CKMRpop---simplicity just get list ancestors whatever order happen reached.","code":""},{"path":"/reference/check_pedigree_for_inbreeding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check the a GSP (in prepped list format) for inbreeding loops — check_pedigree_for_inbreeding","text":"","code":"# get the 13 member pedigree in the data object GSP and # turn it into a list GP <- prep_gsp_for_hap_dropping(GSP)  # check it for inbreeding. (There is none) check_pedigree_for_inbreeding(GP)  if (FALSE) { # To see what happens if there are inbreeding loops, make some GP_inbred <-  GP # make 12 be inbred trough individual 6 GP_inbred$`12`$par1$par = \"13\" # make 8 inbred (because both of its founder parents are the same!) GP_inbred$`8`$par2$par = \"4\"  # now try that: check_pedigree_for_inbreeding(GP_inbred)  }"},{"path":"/reference/computeQs_from_segments.html","id":null,"dir":"Reference","previous_headings":"","what":"return the admixture fractions of sampled individuals — computeQs_from_segments","title":"return the admixture fractions of sampled individuals — computeQs_from_segments","text":"operates output segregate add lengths segments segregated different individuals thus compute admixture fractions sampled individual.","code":""},{"path":"/reference/computeQs_from_segments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"return the admixture fractions of sampled individuals — computeQs_from_segments","text":"","code":"computeQs_from_segments(S, check_total_length = TRUE)"},{"path":"/reference/computeQs_from_segments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"return the admixture fractions of sampled individuals — computeQs_from_segments","text":"S tibble output segregate check_total_length TRUE means checks total genome length individual make sure checks .","code":""},{"path":"/reference/computeQs_from_segments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"return the admixture fractions of sampled individuals — computeQs_from_segments","text":"function returns tibble following columns: gpp: genomic simulation pedigree within individual sample simulated. rep: number replicate simulation ped_sample_id: id number sampled individual genomic simulation pedigree. samp_index: index sample taken.  individuals genomic simulation pedigrees can produce one sample. number tells sample . pop_origin: \"pedigree\" population origin segments contributed group_length.  simple \"\", \"B\", \"C\", etc. designations given genomic simulation pedigree. group_origin: group samples segments contributing group_length originated .  groups samples mapped onto simple pedigree pop_origins reppop request. group_length: total length segments group individual rep gpp (bases). tot_length: total number bases origins carried individual. admixture_fraction: fraction bases simulated individual originate group group_origin.","code":""},{"path":"/reference/computeQs_from_segments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"return the admixture fractions of sampled individuals — computeQs_from_segments","text":"","code":"#### Get output from segregate to use as input #### # We construct an example here where we will request segregation # down a GSP with two F1s and F1B backcrosses between two hypothetical # populations, A and B. gsp_f1f1b <- create_GSP(\"A\", \"B\", F1 = TRUE, F1B = TRUE)  # We will imagine that in our marker data there are three groups # labelled \"grp1\", \"grp2\", and \"grp3\", and we want to create the F1Bs with backcrossing # only to grp3. reppop <- tibble::tibble(   rep = c(1, 1, 2, 2),   pop = c(\"A\", \"B\", \"A\", \"B\"),   group = c(\"grp3\", \"grp1\", \"grp3\", \"grp2\") )  # combine those into a request request <- tibble::tibble(   gpp = list(gsp_f1f1b),   reppop = list(reppop) )  # now run it through segregate() set.seed(5)  # just for reproducibility in example... simSegs <- segregate(request, RecRates)  #### Now we can run those through computeQs_from_segments() #### Qs <- computeQs_from_segments(simSegs) #> Error in filter(., !near(tot_length, tot_len_by_max, tol = 1e-04)): Problem while computing `..1 = !near(tot_length, tot_len_by_max, tol = #> 1e-04)`. #> ℹ The error occurred in group 1: gpp = 1, rep = 1, ped_sample_id = \"4\", #>   samp_index = 1. #> Caused by error in `near()`: #> ! could not find function \"near\"  Qs #> Error in eval(expr, envir, enclos): object 'Qs' not found"},{"path":"/reference/create_GSP.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a GSP from user inputs about what type of hybrids from which populations to create hybrids — create_GSP","title":"Create a GSP from user inputs about what type of hybrids from which populations to create hybrids — create_GSP","text":"function allows user choose two populations create GSP input gscramble. input requires two different population IDs class character well least one TRUE statement one hybrid parameters (F1, F2, F1B, F1B2). GSP indicate hybrid individuals sampled based F1, F2, F1B, F1B2 parameters TRUE. F1= TRUE means F1 hybrids sampled. F2=TRUE means F2 hybrids sampled. F1B2=TRUE means F1 backcross hybrids sampled. F1B2=TRUE means F1 backcross 2 hybrids sampled. Default setting parameters FALSE. function outputs GSP tibble format can used functions gscramble including \"check_pedigree_for_inbreeding\" \"prep_gsp_for_hap_dropping\".","code":""},{"path":"/reference/create_GSP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a GSP from user inputs about what type of hybrids from which populations to create hybrids — create_GSP","text":"","code":"create_GSP(pop1, pop2, F1 = F, F2 = F, F1B = F, F1B2 = F)"},{"path":"/reference/create_GSP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a GSP from user inputs about what type of hybrids from which populations to create hybrids — create_GSP","text":"pop1 character name population 1 pop2 character name population 2 F1 logical indicating whether like sampled F1 hybrids output. F2 logical indicating whether like sampled F2 hybrids output. F1B logical indicating whether like sampled F1 backcross hybrids output. F1B2 logical indicating whether like sampled F1 backcross 2 hybrids output.","code":""},{"path":"/reference/create_GSP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a GSP from user inputs about what type of hybrids from which populations to create hybrids — create_GSP","text":"function returns GSP tibble format user argument pop1 pop2 autopopulated hpop1 hpop2 columns.","code":""},{"path":"/reference/create_GSP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a GSP from user inputs about what type of hybrids from which populations to create hybrids — create_GSP","text":"","code":"# create a GSP that generates hybrids and samples F1s and F1B's from pops A and B gsp <- create_GSP(\"A\", \"B\", F1 = TRUE, F1B = TRUE)  #create a GSP that generates hybrids and samples F1s, F2s, F1Bs, F1B2s from pops A and B gsp <- create_GSP(\"Pop_X\", \"Pop_Z\", F1 = TRUE, F2 = TRUE, F1B = TRUE, F1B2 = TRUE)"},{"path":"/reference/drop_segs_down_gsp.html","id":null,"dir":"Reference","previous_headings":"","what":"High level function for dropping segments down a GSP — drop_segs_down_gsp","title":"High level function for dropping segments down a GSP — drop_segs_down_gsp","text":"one asks number reps , also automatically chromosomes returns results nice tidy tibble.","code":""},{"path":"/reference/drop_segs_down_gsp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"High level function for dropping segments down a GSP — drop_segs_down_gsp","text":"","code":"drop_segs_down_gsp(GSP, RR, Reps)"},{"path":"/reference/drop_segs_down_gsp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"High level function for dropping segments down a GSP — drop_segs_down_gsp","text":"GSP pedigree use simulation, format package data GSP. RR recombination rates format package data RecRates Reps number times simulation.  Different replicates denoted rep column output tibble.","code":""},{"path":"/reference/drop_segs_down_gsp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"High level function for dropping segments down a GSP — drop_segs_down_gsp","text":"","code":"simSegs <- drop_segs_down_gsp(GSP, RecRates, 4)"},{"path":"/reference/full_analysis.html","id":null,"dir":"Reference","previous_headings":"","what":"A full analysis of the included feral pig data — full_analysis","title":"A full analysis of the included feral pig data — full_analysis","text":"put function makes easier make dependency graph different functions package. actually anything except call high-level functions one call typical full analysis. can make function dependency graph like :","code":"library(DependenciesGraphs) deps <- funDependencies(\"package:gscramble\", \"full_analysis\") plot(deps)"},{"path":"/reference/full_analysis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A full analysis of the included feral pig data — full_analysis","text":"","code":"full_analysis()"},{"path":"/reference/full_analysis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A full analysis of the included feral pig data — full_analysis","text":"","code":"if (FALSE) { library(gscramble) library(DependenciesGraphs) deps <- funDependencies(\"package:gscramble\", \"full_analysis\") plot(deps) }"},{"path":"/reference/gscramble2plink.html","id":null,"dir":"Reference","previous_headings":"","what":"Write gscramble I_meta, M_meta, and Geno to a plink file — gscramble2plink","title":"Write gscramble I_meta, M_meta, and Geno to a plink file — gscramble2plink","text":"Writes genetic individual information gscramble's I_meta, M_meta, Geno like objects uncompressed plink .ped .map files.","code":""},{"path":"/reference/gscramble2plink.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write gscramble I_meta, M_meta, and Geno to a plink file — gscramble2plink","text":"","code":"gscramble2plink(I_meta, M_meta, Geno, prefix = tempfile())"},{"path":"/reference/gscramble2plink.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write gscramble I_meta, M_meta, and Geno to a plink file — gscramble2plink","text":"I_meta tibble individual meta data least columns group indiv. M_meta tibble marker meta data least columns chrom, pos, variant_id. Geno character matrix genotypes.  Num-indivs rows num-markers * 2 columns, missing denoted denoted NA. prefix file path prefix write files","code":""},{"path":"/reference/gscramble2plink.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write gscramble I_meta, M_meta, and Geno to a plink file — gscramble2plink","text":"Returns TRUE successful.","code":""},{"path":"/reference/gscramble2plink.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write gscramble I_meta, M_meta, and Geno to a plink file — gscramble2plink","text":"","code":"gscramble2plink(I_meta, M_meta, Geno) #> pedfile written to /var/folders/xg/mz_qt7q54yv_hwzvhskwx2c00000gp/T//Rtmp79Cbgt/file8c95e48cdbe.ped #> mapfile written to /var/folders/xg/mz_qt7q54yv_hwzvhskwx2c00000gp/T//Rtmp79Cbgt/file8c95e48cdbe.map #> [1] TRUE"},{"path":"/reference/gsp2dot.html","id":null,"dir":"Reference","previous_headings":"","what":"Write a dot file to represent a genome simulation pedigree — gsp2dot","title":"Write a dot file to represent a genome simulation pedigree — gsp2dot","text":"takes tibble representation GSP writes dot file rendered graph using dot command GraphViz package.  can easily get GraphViz using Miniconda check GraphViz downloads page.  dot executable PATH, dot run dot file SVG PNG image graph.","code":""},{"path":"/reference/gsp2dot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write a dot file to represent a genome simulation pedigree — gsp2dot","text":"","code":"gsp2dot(   g,   path = file.path(tempfile(), \"file_prefix\"),   edge_label_font_size = 18,   haplo_origin_colors = c(\"lightblue\", \"orange\", \"blue\", \"green\"),   sam_node_color = \"violet\",   sample_edge_label_color = \"purple\",   parent_edge_label_color = \"red\" )"},{"path":"/reference/gsp2dot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write a dot file to represent a genome simulation pedigree — gsp2dot","text":"g GSP tibble. path path file prefix use (appended .dot, .png .svg, dot system). default paths temporary directory, packages allowed write user home directories default.  Supply path prefix, like my_path/myfile get output file mypath.myfile.dot edge_label_font_size font size number annotations along edges. haplo_origin_colors colors different origins haplotypes. default four.  populations founders may come , add . sam_node_color color given sample nodes GSP. sample_edge_label_color Color numeric annotations along edges leading samples. parent_edge_label_color Color numeric annotations along edges leading parents offspring.","code":""},{"path":"/reference/gsp2dot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write a dot file to represent a genome simulation pedigree — gsp2dot","text":"vector file paths.  first path dot file produced.  second third present dot found PATH.  paths png svg files produced.","code":""},{"path":"/reference/gsp2dot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write a dot file to represent a genome simulation pedigree — gsp2dot","text":"can tricky knowing whether R Rstudio read Unix rc files populate paths appropriately.  want test whether dot PATH running R, try: Sys.(\"dot\") R console.  returns empty string, (\"\"), need something else make sure R can find dot system.","code":""},{"path":"/reference/gsp2dot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write a dot file to represent a genome simulation pedigree — gsp2dot","text":"","code":"gsp_file <- system.file(\"extdata/13-member-ped.csv\", package = \"gscramble\") g <- readr::read_csv(gsp_file) #> Rows: 13 Columns: 11 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \",\" #> chr (5): hap1, hap2, hpop1, hpop2, sample #> dbl (6): ind, par1, par2, ipar1, ipar2, osample #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.  paths <- gsp2dot(g) #> Cannot find dot on the system path. Returning the path to just the dot file, but not the rendered png and svg files. paths #>                                                                                            dot  #> \"/var/folders/xg/mz_qt7q54yv_hwzvhskwx2c00000gp/T//Rtmp79Cbgt/file8c977a498d3/file_prefix.dot\""},{"path":"/reference/gsp3.html","id":null,"dir":"Reference","previous_headings":"","what":"Tibble holding specification for a 5 member genomic permutation pedigree. — gsp3","title":"Tibble holding specification for a 5 member genomic permutation pedigree. — gsp3","text":"3 founders","code":""},{"path":"/reference/gsp3.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Tibble holding specification for a 5 member genomic permutation pedigree. — gsp3","text":"tibble","code":""},{"path":"/reference/gsp3.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Tibble holding specification for a 5 member genomic permutation pedigree. — gsp3","text":"Tim made !","code":""},{"path":"/reference/gsp3.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tibble holding specification for a 5 member genomic permutation pedigree. — gsp3","text":"Need document little ....","code":""},{"path":"/reference/gsp4.html","id":null,"dir":"Reference","previous_headings":"","what":"Tibble holding specification for a 7 member genomic permutation pedigree. — gsp4","title":"Tibble holding specification for a 7 member genomic permutation pedigree. — gsp4","text":"4 founders, one different population, provides four samples product F1 matings (x B F1 crossing C x D F1.)","code":""},{"path":"/reference/gsp4.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Tibble holding specification for a 7 member genomic permutation pedigree. — gsp4","text":"tibble","code":""},{"path":"/reference/gsp4.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Tibble holding specification for a 7 member genomic permutation pedigree. — gsp4","text":"just made !","code":""},{"path":"/reference/gsp4.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tibble holding specification for a 7 member genomic permutation pedigree. — gsp4","text":"Need document little ....","code":""},{"path":"/reference/make_subscript_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"makes a two-column matrix for subscripting alleles out of a genotype matrix — make_subscript_matrix","title":"makes a two-column matrix for subscripting alleles out of a genotype matrix — make_subscript_matrix","text":"intended applied grouped tibble columns arguments function.","code":""},{"path":"/reference/make_subscript_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"makes a two-column matrix for subscripting alleles out of a genotype matrix — make_subscript_matrix","text":"","code":"make_subscript_matrix(n, chrom, start, end, abs_column, m_list, num_markers)"},{"path":"/reference/make_subscript_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"makes a two-column matrix for subscripting alleles out of a genotype matrix — make_subscript_matrix","text":"n number rows group tibble chrom chromosome names start starting position segment end ending position th segment abs_column absolute column index founder m_list list column markers num_markers number markers","code":""},{"path":"/reference/mat_scramble.html","id":null,"dir":"Reference","previous_headings":"","what":"This function assumes that M is a matrix with L rows (number of markers) and\n2 * N (N = number of individuals) columns.\nThere are two ways that the data might be permuted.  In the first,\nobtained with preserve_haplotypes = FALSE,\nthe position of missing data within the matrix is held constant, but all\nnon-missing sites within a row (i.e. all gene copies at a locus) get\nscrambled amongst the samples.  In the second way, just the columns are\npermuted.  This preserves haplotypes in the data, if there are any.\nThe second approach should only be used if haplotypes are inferred in\nthe individuals. — mat_scramble","title":"This function assumes that M is a matrix with L rows (number of markers) and\n2 * N (N = number of individuals) columns.\nThere are two ways that the data might be permuted.  In the first,\nobtained with preserve_haplotypes = FALSE,\nthe position of missing data within the matrix is held constant, but all\nnon-missing sites within a row (i.e. all gene copies at a locus) get\nscrambled amongst the samples.  In the second way, just the columns are\npermuted.  This preserves haplotypes in the data, if there are any.\nThe second approach should only be used if haplotypes are inferred in\nthe individuals. — mat_scramble","text":"function assumes M matrix L rows (number markers) 2 * N (N = number individuals) columns. two ways data might permuted.  first, obtained preserve_haplotypes = FALSE, position missing data within matrix held constant, non-missing sites within row (.e. gene copies locus) get scrambled amongst samples.  second way, just columns permuted.  preserves haplotypes data, . second approach used haplotypes inferred individuals.","code":""},{"path":"/reference/mat_scramble.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function assumes that M is a matrix with L rows (number of markers) and\n2 * N (N = number of individuals) columns.\nThere are two ways that the data might be permuted.  In the first,\nobtained with preserve_haplotypes = FALSE,\nthe position of missing data within the matrix is held constant, but all\nnon-missing sites within a row (i.e. all gene copies at a locus) get\nscrambled amongst the samples.  In the second way, just the columns are\npermuted.  This preserves haplotypes in the data, if there are any.\nThe second approach should only be used if haplotypes are inferred in\nthe individuals. — mat_scramble","text":"","code":"mat_scramble(M, preserve_haplotypes = !is.null(row_groups), row_groups = NULL)"},{"path":"/reference/mat_scramble.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function assumes that M is a matrix with L rows (number of markers) and\n2 * N (N = number of individuals) columns.\nThere are two ways that the data might be permuted.  In the first,\nobtained with preserve_haplotypes = FALSE,\nthe position of missing data within the matrix is held constant, but all\nnon-missing sites within a row (i.e. all gene copies at a locus) get\nscrambled amongst the samples.  In the second way, just the columns are\npermuted.  This preserves haplotypes in the data, if there are any.\nThe second approach should only be used if haplotypes are inferred in\nthe individuals. — mat_scramble","text":"M matrix L rows (number markers) 2 * N columns N number individuals. Missing data must coded NA preserve_haplotypes logical indicating whether haplotypes set TRUE row_groups NULL must list indexes adjacent rows groups.  example: list(1:10, 11:15, 16:30). order complete. practice, correspond indexes markers different chromosomes.","code":""},{"path":"/reference/perm_gs_by_pops.html","id":null,"dir":"Reference","previous_headings":"","what":"Take the output of rearrange_genos and permute everyone by population — perm_gs_by_pops","title":"Take the output of rearrange_genos and permute everyone by population — perm_gs_by_pops","text":"put together pretty hastily","code":""},{"path":"/reference/perm_gs_by_pops.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Take the output of rearrange_genos and permute everyone by population — perm_gs_by_pops","text":"","code":"perm_gs_by_pops(GS, preserve_haplotypes = FALSE)"},{"path":"/reference/perm_gs_by_pops.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Take the output of rearrange_genos and permute everyone by population — perm_gs_by_pops","text":"GS tibble output rearrange_genos preserve_haplotypes true Geno data assumed phased (first allele individual one haplotype second allele ) haplotypes preserved permutation genomic material amongst founders.","code":""},{"path":"/reference/plink2gscramble.html","id":null,"dir":"Reference","previous_headings":"","what":"read plink-formatted .map and .ped files into gscramble format — plink2gscramble","title":"read plink-formatted .map and .ped files into gscramble format — plink2gscramble","text":"read .ped .map files (can gzipped, binary .bed .bim plink format).  population specifier individual assumed first column (FID column) .ped file.","code":""},{"path":"/reference/plink2gscramble.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"read plink-formatted .map and .ped files into gscramble format — plink2gscramble","text":"","code":"plink2gscramble(map, ped)"},{"path":"/reference/plink2gscramble.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"read plink-formatted .map and .ped files into gscramble format — plink2gscramble","text":"map path plink .map file holding information markers.  file can gzipped ped path plink .ped file holding information individuals genotypes.  file can also gzipped. function assumes second column file unique across family IDs. case, function throws warning. assumed missing genotypes denoted 0's file.","code":""},{"path":"/reference/plink2gscramble.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"read plink-formatted .map and .ped files into gscramble format — plink2gscramble","text":"list three components: I_meta: meta data individuals file.  include columns group (value first column ped file) indiv (ID individual stored second column ped file). wil also include four columns plink ped specification, named follows: pa ma, sex_code, pheno. M_meta: meta data markers.  tibble columns chrom, pos, variant_id link_pos.  link_pos column holds information marker position Morgans cM included map file. Geno: character matrix genotypes number--indviduals rows number--markers * 2 columns. Missing genotypes matrix coded NA.","code":""},{"path":"/reference/plink2gscramble.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"read plink-formatted .map and .ped files into gscramble format — plink2gscramble","text":"","code":"map_plink <- system.file(\"extdata/example-plink.map.gz\", package = \"gscramble\") ped_plink <- system.file(\"extdata/example-plink.ped.gz\", package = \"gscramble\")  result <- plink2gscramble(map_plink, ped_plink)"},{"path":"/reference/plot_simulated_chromomsome_segments.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the simulated chromosomes of an individual — plot_simulated_chromomsome_segments","title":"Plot the simulated chromosomes of an individual — plot_simulated_chromomsome_segments","text":"function uses information tibble segments dropped genome simulation pedigree plot chromomomes individual colored either population origin segment founding haplotype origin segment.","code":""},{"path":"/reference/plot_simulated_chromomsome_segments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the simulated chromosomes of an individual — plot_simulated_chromomsome_segments","text":"","code":"plot_simulated_chromomsome_segments(   Segs,   RR = NULL,   rel_heights = c(chrom_ht = 4, chrom_gap = 0.8, spark_gap = 0.6 * !is.null(RR),     spark_box = 2.2 * !is.null(RR), unit_gap = 4),   bottom_gap = 0.3 )"},{"path":"/reference/plot_simulated_chromomsome_segments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the simulated chromosomes of an individual — plot_simulated_chromomsome_segments","text":"Segs tibble segments RR tibble recombination rates bins format RecRates. included, recombination rates cM/Mb plotted atop chromosomes little sparkline. included, little sparklines chromsomes. rel_heights vector relative heights different elements chromosomal unit plot.  named vector following elements, listed order bottom unit top: chrom_ht: height bars two chromosomes pair chromosome unit. chrom_gap: gap two homologous chromosomes individual. spark_gap: gap top chromosome sparkline box recombination rates. spark_box: height box within sparkline goes.  Note sparkline scaled highest rate anywhere within genome correspond top spark box. unit_gap: relative height gap one chromosome unit next. bottom_gap y value bottom chromosome unit.  Basically absolute distance y=0 line start plotted material. typically 0 1.","code":""},{"path":"/reference/plot_simulated_chromomsome_segments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the simulated chromosomes of an individual — plot_simulated_chromomsome_segments","text":"","code":"# must add some"},{"path":"/reference/prep_gsp_for_hap_dropping.html","id":null,"dir":"Reference","previous_headings":"","what":"Take a gsp in tibble form and make a list suitable for gene dropping — prep_gsp_for_hap_dropping","title":"Take a gsp in tibble form and make a list suitable for gene dropping — prep_gsp_for_hap_dropping","text":"Just simple function makes list-based data structure makes easy gene-drop chromosome segments gsp.  basic idea get everyone data structure ordered time get segregating segments anyone, already segments segregated . works individual list gametes (post-recombination) coming , list \"uniters\" gametes coming .  just point uniters gametes previous generation make sure shuffle order gametes come someone.","code":""},{"path":"/reference/prep_gsp_for_hap_dropping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Take a gsp in tibble form and make a list suitable for gene dropping — prep_gsp_for_hap_dropping","text":"","code":"prep_gsp_for_hap_dropping(gsp)"},{"path":"/reference/prep_gsp_for_hap_dropping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Take a gsp in tibble form and make a list suitable for gene dropping — prep_gsp_for_hap_dropping","text":"gsp tibble holds genome simulation pedigree (GSP). tibble row specifies individual GSP.  columns tibble : ind: numeric identifier row's indvidual. par: numeric ID first parent individual (NA individual founder pedigree). par2: numeric ID second parent individual (NA individual founder) ipar1: number gametes par1 must segregate \"\" ind order exhaust genetic material GSP.  values given red numerals alongside edge connecting parents offspring GSP images defined gsp2dot().  See vignette gscramble-tutorial, example. (NA ind founder). ipar2: number gametes par2 must segregate ind. (NA ind founder). hap1: unique character label given first haplotype ind ind founder.  ind founder, must NA. hap2: unique character label given second haplotype ind. NA ind founder. hpop1: character label giving population origin first haplotype (.e., hap1) ind, ind founder.  NA otherwise. hpop2: character label giving population origin second haplotype (.e., hap2) ind.  NA ind founder. sample: unique character label outcoming diploid sample pedigree member ind. NA ind sampled. osample: number diploid samples come ind.  NA ind sampled.","code":""},{"path":"/reference/prep_gsp_for_hap_dropping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Take a gsp in tibble form and make a list suitable for gene dropping — prep_gsp_for_hap_dropping","text":"function returns named list, linked-list type structure contains information gsp, makes easier access traversing pedigree. length list nrow(gsp). names character versions ind column. component list refers individual row gsp.  list elements lists. (.e., information single individual stored list.) Every individual list least two elements: isSample: TRUE samples taken individual. FALSE otherwise. isFounder: TRUE individual founder.  FALSE otherwise. nGamete: total number gametes segregated individual along edges offspring individual pedigree. sum red numbers alongside edges individual GSP. individual's isSample TRUE, list also contains following elements: nSamples: number diploid genomes sampled individual. purple number along edge sample node individual GSP \"picture\". individual's, isFounder TRUE list also contains following elements: hpop1: population haplotype 1 (founder) individual originated. hpop2: population haplotype 2 (founder) individual originated. fh_idx1: stands \"founding haplotype index 1.  unique integer identifies haplotype one founder individual.  integer unique haplotypes founder individuals. fh_idx2' unique integer identifier haplotype two founder individual. individual's isFounder FALSE, list also contains following elements: par1 par2. list elements: par: character identifier first (par1) second (par2) parent individual. gam_idx: tells us gametes parent (1 2) depending par1 par2, gets segregated individual.  NEED EXPLAIN .  SINCE THINGS GET PERMUTED, ETC.","code":""},{"path":"/reference/prep_gsp_for_hap_dropping.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Take a gsp in tibble form and make a list suitable for gene dropping — prep_gsp_for_hap_dropping","text":"","code":"# get the 13 member complex pedigree in tibble form as the # package data object GSP and prep it: GSP_list <- prep_gsp_for_hap_dropping(GSP)"},{"path":"/reference/rearrange_genos.html","id":null,"dir":"Reference","previous_headings":"","what":"rearrange genotypes into separate columns for each haplotype. — rearrange_genos","title":"rearrange genotypes into separate columns for each haplotype. — rearrange_genos","text":"function first reorders individuals columns matrix every population together.  rearranges genotypes separate columns haplotype (\"halflotype\" unphased.)  prepares matrix different kinds permutation (within populations, example).","code":""},{"path":"/reference/rearrange_genos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rearrange genotypes into separate columns for each haplotype. — rearrange_genos","text":"","code":"rearrange_genos(G, Im, Mm)"},{"path":"/reference/rearrange_genos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rearrange genotypes into separate columns for each haplotype. — rearrange_genos","text":"G genotype matrix (N rows 2L columns) Im meta data N samples. Mm meta data L markers.","code":""},{"path":"/reference/rearrange_genos.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"rearrange genotypes into separate columns for each haplotype. — rearrange_genos","text":"returns list.  One component matrix, another updated individual meta data, third marker meta data.","code":""},{"path":"/reference/recomb_point.html","id":null,"dir":"Reference","previous_headings":"","what":"Randomly sample the positions of recombinations on a chromosome — recomb_point","title":"Randomly sample the positions of recombinations on a chromosome — recomb_point","text":"function uses observed recombination fractions data object RecRates.  observed recombination fractions series adjacent small bins defined start position start_pos ending position end_pos.  function operates recombination rates single chromosome time, typically wrapped inside purrr::map() function operate multiple chromosomes.","code":""},{"path":"/reference/recomb_point.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Randomly sample the positions of recombinations on a chromosome — recomb_point","text":"","code":"recomb_point(M, at_least_one = TRUE)"},{"path":"/reference/recomb_point.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Randomly sample the positions of recombinations on a chromosome — recomb_point","text":"M tibble columns start_pos, end_pos, rec_prob (rec_prob probability recombination occurring meiosis within interval defined start_pos end_pos.","code":""},{"path":"/reference/recomb_point.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Randomly sample the positions of recombinations on a chromosome — recomb_point","text":"two main modes function operates. at_least_one == TRUE, chromosome always least one recombination.  case, position first recombination chosen according recombination rates.  Subsequently, remaining number recombinations chosen random variable Y, greater zero X - 1, X Poisson r.v. mean given sum recombination fractions.  additional recombinations placed randomly according rec_probs without interference. at_least_one == FALSE total number recombinations simulated Poisson r.v. mean equal sum recombination fractions. , placement assumes interference. Locations within bin chosen uniformly.  locations represented real number (rather integers) used describing segments, well.  simplifies matters condensing information multiple recombinations occurred base pair.  practice, negligible effects, since unlikely recombination ever occur place. recombination occurs, just returns zero-length numeric vector.","code":""},{"path":"/reference/recomb_point.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Randomly sample the positions of recombinations on a chromosome — recomb_point","text":"","code":"# for an example, create a tibble of bins, roughly 1 Mb each, # on a chromosome of length roughly 150 Mb, and we assign each # a rec_prob around 0.01 ends <- seq(1e6, 150e6, by = 1e6) ends <- ends + floor(runif(length(ends), min = -1e4, max = 1e4)) set.seed(5) M <- tibble::tibble(     start_pos = c(0, ends[-length(ends)] + 1),     end_pos = ends,     rec_prob = abs(rnorm(length(ends), 0.01, 0.004)) ) recomb_point(M) #> [1]  10303561  67981023 130792018"},{"path":"/reference/seg2tib.html","id":null,"dir":"Reference","previous_headings":"","what":"Takes a gamete in segment format and returns a tibble with Pop and indiv_index — seg2tib","title":"Takes a gamete in segment format and returns a tibble with Pop and indiv_index — seg2tib","text":"small helper function.","code":""},{"path":"/reference/seg2tib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Takes a gamete in segment format and returns a tibble with Pop and indiv_index — seg2tib","text":"","code":"seg2tib(s)"},{"path":"/reference/seg2tib.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Takes a gamete in segment format and returns a tibble with Pop and indiv_index — seg2tib","text":"s gamete segment format","code":""},{"path":"/reference/seg_haps_through_gsp.html","id":null,"dir":"Reference","previous_headings":"","what":"Segregate haplotypes through a genome simulation pedigree list — seg_haps_through_gsp","title":"Segregate haplotypes through a genome simulation pedigree list — seg_haps_through_gsp","text":"main input list prepared prep_gsp_for_hap_dropping. returns list form, extra variables , important future use Samples, lists hold founder segments made sampled individuals.","code":""},{"path":"/reference/seg_haps_through_gsp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Segregate haplotypes through a genome simulation pedigree list — seg_haps_through_gsp","text":"","code":"seg_haps_through_gsp(   G,   M,   chrom_len,   pop_idx_sep = \"--%--\",   recomb_model = \"always one\" )"},{"path":"/reference/seg_haps_through_gsp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Segregate haplotypes through a genome simulation pedigree list — seg_haps_through_gsp","text":"G genome simulation pedigree list, ready go M map information.  tibble start_pos end_pos rec_prob chrom_len length chromosome base pairs pop_idx_sep string use separate index pop index founder naming chromosomal segments come .  recommended changed. recomb_model used now, want add , eventually, specify kind recombination model using, modify recomb_point accommodate different choices.","code":""},{"path":"/reference/seg_haps_through_gsp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Segregate haplotypes through a genome simulation pedigree list — seg_haps_through_gsp","text":"low-level function user typically use.","code":""},{"path":"/reference/segments2markers.html","id":null,"dir":"Reference","previous_headings":"","what":"Just a big, messy wrapper to wrap up some things so Tim can use them — segments2markers","title":"Just a big, messy wrapper to wrap up some things so Tim can use them — segments2markers","text":"Just big, messy wrapper wrap things Tim can use ","code":""},{"path":"/reference/segments2markers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Just a big, messy wrapper to wrap up some things so Tim can use them — segments2markers","text":"","code":"segments2markers(Segs, Im, Mm, G)"},{"path":"/reference/segments2markers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Just a big, messy wrapper to wrap up some things so Tim can use them — segments2markers","text":"Segs simulated segments Im individual meta data, like I_meta Mm marker meta data formatted like M_meta G marker genotype data matrix like Geno","code":""},{"path":"/reference/segregate.html","id":null,"dir":"Reference","previous_headings":"","what":"Segregate segments down genomic simulation pedigrees — segregate","title":"Segregate segments down genomic simulation pedigrees — segregate","text":"Given collection genomic simulation pedigrees requests many simulations done (request input), well recombination rates, simulates segregation segments pedigrees","code":""},{"path":"/reference/segregate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Segregate segments down genomic simulation pedigrees — segregate","text":"","code":"segregate(request, RR, MM = NULL)"},{"path":"/reference/segregate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Segregate segments down genomic simulation pedigrees — segregate","text":"request tibble list columns \"gpp\" \"reppop\". element gpp column tibble giving genomic simulation pedigree documented input prep_gsp_for_hap_dropping(). element \"reppop\" column tibble columns rep, pop, group, indicate founding populations (\"\", \"B\", etc.) correspond different groups (group column , example, meta data individuals genotype data set, like data object I_meta). quite likely might wish iterate segregation procedure multiple times single simulation, can specify multiple \"reps\" (replicates) procedure.  BIG NOTE: reps choose must start 1 dense within.  words, max value reps column N, every integer 1 N must . RR recombination rates format package data MM marker meta data tibble (like M_meta).  NULL (default) fine.  , uses order markers MM define levels chrom_f column can sort rows output correctly, respect markers Genotype data frame.  let us efficiently subscript markers matrix. MM present, function create chrom_f using order chromosomes RR. RecRates","code":""},{"path":"/reference/segregate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Segregate segments down genomic simulation pedigrees — segregate","text":"","code":"# We construct an example here where we will request segregation # down a GSP with two F1s and F1B backcrosses between two hypothetical # populations, A and B. gsp_f1f1b <- create_GSP(\"A\", \"B\", F1 = TRUE, F1B = TRUE)  # We will imagine that in our marker data there are three groups # labelled \"grp1\", \"grp2\", and \"grp3\", and we want to create the F1Bs with backcrossing # only to grp3. reppop <- tibble::tibble(     rep = c(1, 1, 2, 2),     pop = c(\"A\", \"B\", \"A\", \"B\"),     group = c(\"grp3\", \"grp1\", \"grp3\", \"grp2\") )  # combine those into a request request <- tibble::tibble(    gpp = list(gsp_f1f1b),    reppop = list(reppop) )   result1 <- segregate(request, RecRates)  # here we pass it some markers, too result2 <- segregate(request, RecRates, M_meta)  result1 #> # A tibble: 48 × 14 #>    chrom_f   gpp   rep chrom ped_sample_id samp_index gamete_index #>    <fct>   <int> <dbl> <chr> <chr>              <int>        <dbl> #>  1 12          1     1 12    4                      1            1 #>  2 17          1     1 17    4                      1            1 #>  3 18          1     1 18    4                      1            1 #>  4 12          1     1 12    4                      1            2 #>  5 17          1     1 17    4                      1            2 #>  6 18          1     1 18    4                      1            2 #>  7 12          1     1 12    5                      1            1 #>  8 17          1     1 17    5                      1            1 #>  9 18          1     1 18    5                      1            1 #> 10 12          1     1 12    5                      1            2 #> # … with 38 more rows, and 7 more variables: gamete_segments <list>, #> #   pop_origin <chr>, rs_founder_haplo <int>, start <dbl>, end <dbl>, #> #   group_origin <chr>, sim_level_founder_haplo <int>  result2 #> # A tibble: 50 × 14 #>    chrom_f   gpp   rep chrom ped_sample_id samp_index gamete_index #>    <fct>   <int> <dbl> <chr> <chr>              <int>        <dbl> #>  1 12          1     1 12    4                      1            1 #>  2 17          1     1 17    4                      1            1 #>  3 18          1     1 18    4                      1            1 #>  4 12          1     1 12    4                      1            2 #>  5 17          1     1 17    4                      1            2 #>  6 18          1     1 18    4                      1            2 #>  7 12          1     1 12    5                      1            1 #>  8 17          1     1 17    5                      1            1 #>  9 18          1     1 18    5                      1            1 #> 10 12          1     1 12    5                      1            2 #> # … with 40 more rows, and 7 more variables: gamete_segments <list>, #> #   pop_origin <chr>, rs_founder_haplo <int>, start <dbl>, end <dbl>, #> #   group_origin <chr>, sim_level_founder_haplo <int>"},{"path":"/reference/sim_level_founder_haplos.html","id":null,"dir":"Reference","previous_headings":"","what":"computes the simulation-level founder haplotype index for each founder haplo — sim_level_founder_haplos","title":"computes the simulation-level founder haplotype index for each founder haplo — sim_level_founder_haplos","text":"takes output segregate() deals multiple gpp's reps come unique index found haplotype, haplotypes can , eventually, accessed easily genotype matrix. Along way, function light checking make sure rs_founder_haplo values dense within gpp rep .","code":""},{"path":"/reference/sim_level_founder_haplos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computes the simulation-level founder haplotype index for each founder haplo — sim_level_founder_haplos","text":"","code":"sim_level_founder_haplos(S)"},{"path":"/reference/sim_level_founder_haplos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computes the simulation-level founder haplotype index for each founder haplo — sim_level_founder_haplos","text":"S tibble segments like produced segregate.","code":""},{"path":"/reference/sim_level_founder_haplos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computes the simulation-level founder haplotype index for each founder haplo — sim_level_founder_haplos","text":"function returns result basically output segregate() additional column added :  sim_level_founder_haplo.  index haplotype within group_origin used. details columns output tibble, see documentation segregate.","code":""},{"path":"/reference/sim_level_founder_haplos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"computes the simulation-level founder haplotype index for each founder haplo — sim_level_founder_haplos","text":"","code":"#### Get output from segregate to use as input #### # We construct an example here where we will request segregation # down a GSP with two F1s and F1B backcrosses between two hypothetical # populations, A and B. gsp_f1f1b <- create_GSP(\"A\", \"B\", F1 = TRUE, F1B = TRUE)  # We will imagine that in our marker data there are three groups # labelled \"grp1\", \"grp2\", and \"grp3\", and we want to create the F1Bs with backcrossing # only to grp3. reppop <- tibble::tibble(   rep = c(1, 1, 2, 2),   pop = c(\"A\", \"B\", \"A\", \"B\"),   group = c(\"grp3\", \"grp1\", \"grp3\", \"grp2\") )  # combine those into a request request <- tibble::tibble(   gpp = list(gsp_f1f1b),   reppop = list(reppop) )  # now run it through segregate() set.seed(5)  # just for reproducibility in example... simSegs <- segregate(request, RecRates)  #### Now we can run those through sim_level_founder_haplos() #### fh <- sim_level_founder_haplos(simSegs) fh #> # A tibble: 52 × 15 #>    chrom_f   gpp   rep chrom ped_sample_id samp_index gamete_index #>    <fct>   <int> <dbl> <chr> <chr>              <int>        <dbl> #>  1 12          1     1 12    4                      1            1 #>  2 17          1     1 17    4                      1            1 #>  3 18          1     1 18    4                      1            1 #>  4 12          1     1 12    4                      1            2 #>  5 17          1     1 17    4                      1            2 #>  6 18          1     1 18    4                      1            2 #>  7 12          1     1 12    5                      1            1 #>  8 17          1     1 17    5                      1            1 #>  9 18          1     1 18    5                      1            1 #> 10 12          1     1 12    5                      1            2 #> # … with 42 more rows, and 8 more variables: gamete_segments <list>, #> #   pop_origin <chr>, rs_founder_haplo <int>, start <dbl>, end <dbl>, #> #   group_origin <chr>, sim_level_founder_haplo.x <int>, #> #   sim_level_founder_haplo.y <int>"},{"path":"/reference/tidy_up_sampled_haplos.html","id":null,"dir":"Reference","previous_headings":"","what":"takes the waka_waka table and returns a simple tibble with results for each sampled ","title":"takes the waka_waka table and returns a simple tibble with results for each sampled ","text":"takes waka_waka table returns simple tibble results sampled \"hybridized\" gamete chromosome #' yet documented","code":""},{"path":"/reference/tidy_up_sampled_haplos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"takes the waka_waka table and returns a simple tibble with results for each sampled ","text":"","code":"tidy_up_sampled_haplos(W)"},{"path":"/reference/tidy_up_sampled_haplos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"takes the waka_waka table and returns a simple tibble with results for each sampled ","text":"W tibble.  see used code .","code":""},{"path":"/reference/xover.html","id":null,"dir":"Reference","previous_headings":"","what":"internal function to do crossovers and create recombinations — xover","title":"internal function to do crossovers and create recombinations — xover","text":"function choose recombination points.  done function recomb_point(), results passed function. two inputs V1 V2 represent two gametes coming individual pedigree. Recombination occurs within individual, two resulting gametes recombination output.  Typically way things happen, course.  Generally, one two resulting gametes recombination segregated surviving offspring. , since interested segregating genetic material without duplicating destroying , keep track gametes result meiosis/recombination.","code":""},{"path":"/reference/xover.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"internal function to do crossovers and create recombinations — xover","text":"","code":"xover(V1, V2, R)"},{"path":"/reference/xover.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"internal function to do crossovers and create recombinations — xover","text":"V1 integer vector recombination points already existing first incoming gamete.  names names founder haplotype left end originates (.e. named haplotype changes point).  example c(= 0, B = 12890, B = 30000) work 30 Kb chromosome single recombination just right point 12890. (example, positions 1 12890 founder haplotype , positions 12891 30000 founder haplotype B.) Note vectors first value 0 final value chromosome length. V2 integer vector breakpoints second incoming gamete.  Format just like V1. R vector new breakpoints insert existing ones gamete. usually returned function recomb_point().","code":""},{"path":"/reference/xover.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"internal function to do crossovers and create recombinations — xover","text":"sends back two updated gametes, V1 V2, new points recombination stuck .  Note, two incoming gametes two outgoing gametes, \"re-using\" genomic sequence.","code":""},{"path":"/reference/xover.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"internal function to do crossovers and create recombinations — xover","text":"","code":"#' # make the two gametes/chromosomes coming into the function. #' # Each one has length 30000 and a single existing recombination V1 <- c(A = 0, B = 10000, B = 30000) V2 <- c(C = 0, D = 20000, D = 30000)  # now, set a new recombination point at position 15000 xover(V1, V2, R = 15000) #> [[1]] #>     A     B     C     D     D  #>     0 10000 15000 20000 30000  #>  #> [[2]] #>     C     B     B  #>     0 15000 30000  #>   # set three recombination points at 5,000, 15,000, and 25,000: xover(V1, V2, R = c(5000, 15000, 25000)) #> [[1]] #>     A     C     B     D     D  #>     0  5000 15000 25000 30000  #>  #> [[2]] #>     C     A     B     C     D     B     B  #>     0  5000 10000 15000 20000 25000 30000  #>   # no recombinations (R is a zero length numeric vector) xover(V1, V2, R = numeric(0)) #> $V1 #>     A     B     B  #>     0 10000 30000  #>  #> $V2 #>     C     D     D  #>     0 20000 30000  #>"}]
